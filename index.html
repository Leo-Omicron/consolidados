<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dashboard Académico Consolidado</title>

<script>
/** Hito 2 (C) – Modo global determinista para todo el documento
 *  Regla: ?mode=prod fuerza PRODUCCIÓN; ?mode=dev fuerza DESARROLLO.
 *  Si no hay query param y window.__PROD__ ya estaba definido, se respeta.
 *  Efecto: fija window.__PROD__ y data-mode en <html> para CSS/JS.
 */
(function () {
  var params = new URLSearchParams(location.search);
  var qp = (params.get("mode") || "").toLowerCase();

  if (qp === "prod")      window.__PROD__ = true;
  else if (qp === "dev")  window.__PROD__ = false;
  else if (typeof window.__PROD__ === "undefined") {
    window.__PROD__ = false; // por defecto, desarrollo
  }

  // Señal visible y utilizable por CSS/JS
  var mode = window.__PROD__ ? "prod" : "dev";
  document.documentElement.dataset.mode = mode;

  // Si activas __DASH_DEV__, muestra un aviso útil
  if (window.__DASH_DEV__) {
    console.log("[MODE]", "Aplicación en modo:", mode.toUpperCase());
  }
})();
</script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM + Babel -->
  <!-- BACKUP (rollback rápido):
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
-->

<!-- BACKUP (rollback rápido) del switch previo con createElement(...) -->
<!--
<script>
/** Hito 2 (C) – Switch Dev/Prod (React/ReactDOM UMD) sin romper Babel ni la app
 *  Modo por defecto: DEV. Forzar PROD con ?mode=prod o window.__PROD__=true.
 *  No tocar Babel por ahora (se mantiene para garantizar estabilidad).
 */
(function () {
  var REACT_DEV = "https://unpkg.com/react@18/umd/react.development.js";       // URL exacta previa (development.js)
  var REACTDOM_DEV = "https://unpkg.com/react-dom@18/umd/react-dom.development.js"; // URL exacta previa (development.js)

  // Derivar URLs de producción cambiando "development.js" por "production.min.js"
  var REACT_PROD = REACT_DEV.replace("development.js", "production.min.js");
  var REACTDOM_PROD = REACTDOM_DEV.replace("development.js", "production.min.js");

  var params = new URLSearchParams(location.search);
  var isProd = (params.get("mode") || "").toLowerCase() === "prod" || window.__PROD__ === true;

  function inject(src) {
    var s = document.createElement("script");
    s.src = src;
    s.defer = false; // mantener orden de carga
    document.head.appendChild(s);
  }

  inject(isProd ? REACT_PROD : REACT_DEV);
  inject(isProd ? REACTDOM_PROD : REACTDOM_DEV);
})();
</script>
-->

<!-- Hito 2 (C) – Switch Dev/Prod SÍNCRONO para garantizar React antes de Babel -->
<script>
  (function () {
    // Pega aquí las URLs *development* EXACTAS que usabas antes:
    var REACT_DEV     = "https://unpkg.com/react@18/umd/react.development.js";      // .../react.development.js
    var REACTDOM_DEV  = "https://unpkg.com/react-dom@18/umd/react-dom.development.js";   // .../react-dom.development.js

    // Deriva automáticamente las URLs de producción:
    var REACT_PROD    = REACT_DEV.replace("development.js", "production.min.js");
    var REACTDOM_PROD = REACTDOM_DEV.replace("development.js", "production.min.js");

    var params = new URLSearchParams(location.search);
    var isProd = (params.get("mode") || "").toLowerCase() === "prod" || window.__PROD__ === true;

    // Inyección SINCRÓNICA con crossorigin (preparación SRI, sin cambiar URLs)
    var r1 = '<script src="' + (isProd ? REACT_PROD : REACT_DEV) + '" crossorigin="anonymous"><' + '/script>';
    var r2 = '<script src="' + (isProd ? REACTDOM_PROD : REACTDOM_DEV) + '" crossorigin="anonymous"><' + '/script>';
    document.write(r1);
    document.write(r2);
  })();
</script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin="anonymous"></script>
  <!-- Chart.js para gráficos -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" crossorigin="anonymous"></script>
  <script>
    // Flag persistente para silenciar errores externos en DEV
    (function () {
      const KEY = 'suppressExternalErrors';
      if (localStorage.getItem(KEY) == null) {
        localStorage.setItem(KEY, 'true'); // por defecto ON
      }
      window.__SUPPRESS_EXTERNAL_CONSOLE_NOISE__ = localStorage.getItem(KEY) === 'true';

      // Helper para cambiar y persistir
      window.__setSuppressExternalErrors = (on) => {
        localStorage.setItem(KEY, on ? 'true' : 'false');
        window.__SUPPRESS_EXTERNAL_CONSOLE_NOISE__ = !!on;
      };
    })();
  </script>
  <script>
    // ===============================
    // DEV: Filtro de ruido de extensiones externas
    // - Filtra errores con source 'chrome-extension://', 'rc2Contentscript.js'
    // - Filtra 'Unchecked runtime.lastError', 'message port closed...'
    // - Captura: window.onerror, error event (capture), unhandledrejection,
    //   console.error y console.warn.
    // No afecta la lógica del dashboard.
    // ===============================
    (function () {
      const isEnabled = () => !!window.__SUPPRESS_EXTERNAL_CONSOLE_NOISE__;
      const extSrc = (src) => typeof src === 'string' && (
        src.startsWith('chrome-extension://') || /rc2Contentscript\.js/i.test(src)
      );
      const msgHit = (msg) => {
        const s = String(msg || '');
        return /Unchecked runtime\.lastError/i.test(s)
            || /message port closed/i.test(s)
            || /rc2Contentscript\.js/i.test(s);
      };

      // 1) window.onerror (legacy)
      const originalOnError = window.onerror;
      window.onerror = function (message, source, lineno, colno, error) {
        try {
          if (isEnabled() && (extSrc(source) || msgHit(message))) {
            return true; // silenciado
          }
        } catch (_) {}
        return typeof originalOnError === 'function'
          ? originalOnError.apply(this, arguments)
          : false;
      };

      // 2) Captura en fase 'capture' de eventos 'error'
      window.addEventListener('error', function (ev) {
        try {
          const src = ev?.filename || ev?.target?.src || '';
          const msg = ev?.message || '';
          if (isEnabled() && (extSrc(src) || msgHit(msg))) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
        } catch (_) {}
      }, true);

      // 3) Promesas no manejadas
      window.addEventListener('unhandledrejection', function (ev) {
        try {
          const reason = ev?.reason;
          const text = reason && reason.message ? String(reason.message) : String(reason || '');
          if (isEnabled() && msgHit(text)) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
        } catch (_) {}
      }, true);

      // 4) console.error / console.warn
      const originalConsoleError = console.error;
      console.error = function () {
        try {
          const text = Array.from(arguments).map(a => (a && a.stack) ? a.stack : String(a)).join(' ');
          if (isEnabled() && (msgHit(text) || /chrome-extension:\/\//i.test(text))) {
            return;
          }
        } catch (_) {}
        return originalConsoleError.apply(console, arguments);
      };

      const originalConsoleWarn = console.warn;
      console.warn = function () {
        try {
          const text = Array.from(arguments).map(a => String(a)).join(' ');
          if (isEnabled() && (msgHit(text) || /chrome-extension:\/\//i.test(text))) {
            return;
          }
        } catch (_) {}
        return originalConsoleWarn.apply(console, arguments);
      };
    })();
  </script>
<script>
/** ResourceGuard – Diagnóstico de CDNs y aviso de fallos (no intrusivo)
 *  - Loggea errores de recursos (CORS/SRI/bloqueos).
 *  - Verifica que Tailwind esté aplicando estilos.
 *  - Muestra un banner discreto si algo falla.
 */
(function () {
  // Escucha errores de recursos (scripts/links)
  window.addEventListener('error', function (e) {
    var t = e.target || {};
    var isRes = t.tagName === 'SCRIPT' || t.tagName === 'LINK';
    if (!isRes) return;
    var url = t.src || t.href || '(desconocido)';
    console.warn('[ResourceGuard] Error cargando recurso:', t.tagName, url);
    showBanner('No se pudo cargar un recurso: ' + url + '. Revisa conexión, CORS o SRI.');
  }, true);

  // Tras DOM listo, valida que Tailwind aplique clases utilitarias básicas
  document.addEventListener('DOMContentLoaded', function () {
    // Se usa un breve retraso para dar tiempo al script de Tailwind a escanear el DOM y aplicar estilos.
    setTimeout(function() {
      try {
        var probe = document.createElement('div');
        probe.className = 'hidden p-4';
        document.body.appendChild(probe);
        var cs = window.getComputedStyle(probe);
        var okHidden = cs.display === 'none';
        document.body.removeChild(probe);
        if (!okHidden) {
          console.warn('[ResourceGuard] Tailwind parece no estar activo (clase .hidden no aplicada).');
          showBanner('Tailwind no se aplicó correctamente. Verifica la carga desde cdn.tailwindcss.com.');
        }
      } catch (err) {
        console.warn('[ResourceGuard] Error verificando Tailwind:', err);
      }
    }, 500);
  });

  // Banner minimalista y removible
  function showBanner(msg) {
    if (document.getElementById('res-guard-banner')) return;
    var b = document.createElement('div');
    b.id = 'res-guard-banner';
    b.setAttribute('role', 'status');
    b.style.cssText = 'position:fixed;bottom:8px;left:8px;right:8px;z-index:9999;padding:10px;border-radius:8px;background:#111827;color:#F9FAFB;font:14px/1.4 system-ui,Segoe UI,Roboto;box-shadow:0 4px 16px rgba(0,0,0,.2)';
    b.textContent = '⚠️ ' + msg + ' ';
    var close = document.createElement('button');
    close.textContent = 'Cerrar';
    close.style.cssText = 'margin-left:8px;padding:4px 8px;border-radius:6px;border:1px solid #374151;background:#1F2937;color:#F3F4F6;cursor:pointer';
    close.onclick = function () { b.remove(); };
    b.appendChild(close);
    document.body.appendChild(b);
  }
})();
</script>
  <script type="text/babel">
/** =========================================
 * Hito 1 (B): Flag DEV + DBG + profiling seguro
 * Producción silenciosa por defecto.
 * Para activar depuración en runtime:
 *   window.__DASH_DEV__ = true
 * ========================================= */
window.__DASH_DEV__ = window.__DASH_DEV__ ?? false;

// Evita aplicar el parche más de una vez
if (!window.__DASH_PROF_PATCHED__) {
  window.__DASH_PROF_PATCHED__ = true;

  // Helper de depuración controlado por flag
  window.DBG = (...args) => {
    if (window.__DASH_DEV__) console.log('[DBG]', ...args);
  };

  // Profiling sin "Timer already exists", dev-only
  (function () {
    const timers = new Map();
    const origLog = console.log.bind(console);

    const origTime = console.time?.bind(console);
    const origTimeEnd = console.timeEnd?.bind(console);

    console.time = (label = 'default') => {
      if (!window.__DASH_DEV__) return;        // no-op en prod
      if (timers.has(label)) return;           // evita timers duplicados
      timers.set(label, performance.now());
    };

    console.timeEnd = (label = 'default') => {
      if (!window.__DASH_DEV__) return;        // no-op en prod
      const start = timers.get(label);
      if (start == null) {
        origLog('[DBG] timeEnd sin time previo:', label);
        return;
      }
      const dur = performance.now() - start;
      timers.delete(label);
      origLog(`[time] ${label}: ${dur.toFixed(1)}ms`);
    };
  })();
}
    // ...existing imports and code...

    // =============================
    // Componente de Gráficos (Chart.js)
    // =============================
    function DashboardCharts({ rowsArea, rowsAsignatura }) {
      console.time('render:DashboardCharts');
      const barRef = useRef(null);
      const pieRef = useRef(null);
      const radarRef = useRef(null);
      const charts = useRef({});

      const chartData = useMemo(() => {
        const data = rowsArea || [];
        if (!Array.isArray(data)) {
          return { estados: [], estadoCounts: [], areaLabels: [], areaProms: [] };
        }
        const estados = ['Perdido','En riesgo','Recuperable','Ganable','Ganado'];
        
        const studentStates = new Map();
        data.forEach(r => {
          if (r.estado && r.estado.text && r.estudiante) {
            if (!studentStates.has(r.estudiante)) {
              studentStates.set(r.estudiante, new Set());
            }
            studentStates.get(r.estudiante).add(r.estado.text);
          }
        });

        const estadoCounts = { Perdido: 0, 'En riesgo': 0, Recuperable: 0, Ganable: 0, Ganado: 0 };
        studentStates.forEach(stateSet => {
          stateSet.forEach(s => {
            if (estadoCounts.hasOwnProperty(s)) estadoCounts[s]++;
          });
        });

        const areaLabels = Array.from(new Set(data.map(s => s.area)));
        const areaProms = areaLabels.map(a => {
          const arr = data.filter(s => s.area === a).map(s => s.promActual);
          const nums = arr.filter(v => typeof v === 'number');
          return nums.length ? Number((nums.reduce((s,v)=>s+v,0)/nums.length).toFixed(2)) : 0;
        });

        return { estados, estadoCounts: estados.map(e => estadoCounts[e]), areaLabels, areaProms };
      }, [rowsArea]);

      useEffect(() => {
        if (!chartData) return;
        const { estados, estadoCounts, areaLabels, areaProms } = chartData;

        const mk = (key, ref, cfg) => {
          if (!ref.current) return;
          charts.current[key]?.destroy();
          charts.current[key] = new window.Chart(ref.current, cfg);
        };

        mk('bar', barRef, {
          type: 'bar',
          data: {
            labels: estados,
            datasets: [{ label: 'Distribución de Estados', data: estadoCounts, backgroundColor: ['#ef4444','#fbbf24','#3b82f6','#06b6d4','#22c55e'] }]
          },
          options: { responsive: true, plugins: { legend: { display: false } } }
        });

        mk('pie', pieRef, {
          type: 'pie',
          data: {
            labels: estados,
            datasets: [{ label: 'Estados', data: estadoCounts, backgroundColor: ['#ef4444','#fbbf24','#3b82f6','#06b6d4','#22c55e'] }]
          },
          options: { responsive: true }
        });

        mk('radar', radarRef, {
          type: 'radar',
          data: {
            labels: areaLabels,
            datasets: [{ label: 'Promedio por Área', data: areaProms, backgroundColor: 'rgba(59,130,246,0.2)', borderColor: '#3b82f6' }]
          },
          options: { responsive: true }
        });

        return () => {
          Object.values(charts.current).forEach(c => c?.destroy());
          charts.current = {};
        };
      }, [chartData]);

      const { estados, estadoCounts, areaLabels, areaProms } = chartData || { estados: [], estadoCounts: [], areaLabels: [], areaProms: [] };

      useEffect(() => {
        console.timeEnd('render:DashboardCharts');
      });

      return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 p-4">
          <div>
            <h3 className="font-semibold mb-2 text-center">Distribución de Estados</h3>
            <p className="text-xs text-gray-500 text-center mb-2">Cantidad de estudiantes por estado académico (área principal).</p>
            <canvas ref={barRef} height="180" aria-label="Distribución de estados (barras)" role="img"></canvas>
            <table className="mt-2 text-xs w-full border">
              <caption className="sr-only">Distribución de estudiantes por estado académico</caption>
              <thead>
                <tr className="bg-gray-100">
                  <th scope="col" className="border px-1">Estado</th>
                  <th scope="col" className="border px-1">Cantidad</th>
                </tr>
              </thead>
              <tbody>
                {estados.map((e, i) => (
                  <tr key={e}>
                    <td className="border px-1">{e}</td>
                    <td className="border px-1">{estadoCounts[i]}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          <div>
            <h3 className="font-semibold mb-2 text-center">Estados (Pastel)</h3>
            <p className="text-xs text-gray-500 text-center mb-2">Proporción de estudiantes por estado académico.</p>
            <canvas ref={pieRef} height="180" aria-label="Distribución de estados (pastel)" role="img"></canvas>
            <table className="mt-2 text-xs w-full border">
              <caption className="sr-only">Proporción de estudiantes por estado académico</caption>
              <thead>
                <tr className="bg-gray-100">
                  <th scope="col" className="border px-1">Estado</th>
                  <th scope="col" className="border px-1">Cantidad</th>
                </tr>
              </thead>
              <tbody>
                {estados.map((e, i) => (
                  <tr key={e}>
                    <td className="border px-1">{e}</td>
                    <td className="border px-1">{estadoCounts[i]}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          <div>
            <h3 className="font-semibold mb-2 text-center">Promedio por Área (Radar)</h3>
            <p className="text-xs text-gray-500 text-center mb-2">Promedio general de notas por área académica.</p>
            <canvas ref={radarRef} height="180" aria-label="Promedio por área (radar)" role="img"></canvas>
            <table className="mt-2 text-xs w-full border">
              <caption className="sr-only">Promedio general de notas por área académica</caption>
              <thead>
                <tr className="bg-gray-100">
                  <th scope="col" className="border px-1">Área</th>
                  <th scope="col" className="border px-1">Promedio</th>
                </tr>
              </thead>
              <tbody>
                {(areaLabels || []).map((a, i) => (
                  <tr key={a}>
                    <td className="border px-1">{a}</td>
                    <td className="border px-1">{areaProms[i]}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    // =============================
    // Tabs para navegación (Análisis / Gráficos) con A11y
    // =============================
        // [A11yTabs] manejo de teclas ← → Home End
    function onTabListKeyDown(e) {
      const LEFT = 'ArrowLeft', RIGHT = 'ArrowRight', HOME = 'Home', END = 'End';
      const list = e.currentTarget;
      const tabs = Array.from(list.querySelectorAll('[role="tab"]')).filter(el => !el.hasAttribute('disabled'));
      const current = document.activeElement;
      const idx = tabs.indexOf(current);
      if (idx === -1) return;

      let nextIdx = idx;
      if (e.key === LEFT) nextIdx = (idx - 1 + tabs.length) % tabs.length;
      else if (e.key === RIGHT) nextIdx = (idx + 1) % tabs.length;
      else if (e.key === HOME) nextIdx = 0;
      else if (e.key === END) nextIdx = tabs.length - 1;
      else return;

      e.preventDefault();
      tabs[nextIdx].focus();
      tabs[nextIdx].click(); // asegura selección al navegar
    }

    function DashboardTabs({ dashboardData, onReset, fileName, derived, syncChartsWithFilters, setSyncChartsWithFilters }) {
      console.debug('[Tabs] received derived', { has: !!derived, rowsArea: Array.isArray(derived?.rowsArea) ? derived.rowsArea.length : 'NA' });
      const [tab, setTab] = useState('analisis');

      // LIFTED STATE from DashboardView
      const [courseFilterDV, setCourseFilterDV] = useState('ALL');
      const [studentFilter, setStudentFilter] = useState('');
      const [areaFilter, setAreaFilter] = useState('');
      const [asigFilter, setAsigFilter] = useState('');
      const [estadoFilter, setEstadoFilter] = useState('');

      const dataForAnalysis = useMemo(() => {
        if (!Array.isArray(dashboardData)) return [];
        if (courseFilterDV === 'ALL') return dashboardData;
        return dashboardData.filter(s => (s?.CURSO || '') === courseFilterDV);
      }, [dashboardData, courseFilterDV]);

      const rowsAreaSource = useMemo(() => {
        if (derived && Array.isArray(derived.rowsArea)) {
          return derived.rowsArea;
        }
        // Fallback
        if (!Array.isArray(dataForAnalysis)) return [];
        const fallbackRows = [];
        dataForAnalysis.forEach(st => {
          Object.entries(st.areas).forEach(([areaName, areaData]) => {
            fallbackRows.push({
              id: `${st.id}-${areaName}`, CURSO: st.CURSO, estudiante: st.name, area: areaName,
              defP1: areaData.DEF?.P1, defP2: areaData.DEF?.P2, defP3: areaData.DEF?.P3,
              promActual: areaData.areaStats?.promedioActual, p4Min: areaData.areaStats?.p4Min, estado: areaData.areaStats?.estado
            });
          });
        });
        return fallbackRows;
      }, [dataForAnalysis, derived?.rowsArea]);

      const rowsAsigSource = useMemo(() => {
        if (derived && Array.isArray(derived.rowsAsignatura)) {
          return derived.rowsAsignatura;
        }
        // Fallback
        if (!Array.isArray(dataForAnalysis)) return [];
        const fallbackRows = [];
        dataForAnalysis.forEach(st => {
          Object.entries(st.areas).forEach(([areaName, areaData]) => {
            Object.entries(areaData.asignaturas).forEach(([asigName, asigData]) => {
              fallbackRows.push({
                id: `${st.id}-${areaName}-${asigName}`, CURSO: st.CURSO, estudiante: st.name, area: areaName, asignatura: asigName,
                p1: asigData.P1, p2: asigData.P2, p3: asigData.P3,
                promActual: asigData.promedioActual, p4Min: asigData.p4Min, estado: asigData.estado
              });
            });
          });
        });
        return fallbackRows;
      }, [dataForAnalysis, derived?.rowsAsignatura]);

      const rowsAreaByCourse = useMemo(() => {
        if (courseFilterDV === 'ALL') return rowsAreaSource;
        return rowsAreaSource.filter(r => (r.CURSO || '') === courseFilterDV);
      }, [rowsAreaSource, courseFilterDV]);

      const filteredRowsArea = useMemo(() => {
        if (!rowsAreaByCourse) return [];
        return rowsAreaByCourse.filter(row => {
            const matchStudent = !studentFilter || row.estudiante.toLowerCase().includes(studentFilter.toLowerCase());
            const matchArea = !areaFilter || row.area.toLowerCase().includes(areaFilter.toLowerCase()) || row.area === areaFilter;
            const matchEstado = !estadoFilter || (row.estado?.text && (row.estado.text.toLowerCase().includes(estadoFilter.toLowerCase()) || row.estado.text === estadoFilter));
            return matchStudent && matchArea && matchEstado;
        });
      }, [rowsAreaByCourse, studentFilter, areaFilter, estadoFilter]);

      const rowsAsigByCourse = useMemo(() => {
        if (courseFilterDV === 'ALL') return rowsAsigSource;
        return rowsAsigSource.filter(r => (r.CURSO || '') === courseFilterDV);
      }, [rowsAsigSource, courseFilterDV]);

      const filteredRowsAsignatura = useMemo(() => {
        if (!rowsAsigByCourse) return [];
        return rowsAsigByCourse.filter(row => {
          const matchStudent = !studentFilter || row.estudiante.toLowerCase().includes(studentFilter.toLowerCase());
          const matchArea = !areaFilter || row.area.toLowerCase().includes(areaFilter.toLowerCase()) || row.area === areaFilter;
          const matchAsig = !asigFilter || row.asignatura.toLowerCase().includes(asigFilter.toLowerCase()) || row.asignatura === asigFilter;
          const matchEstado = !estadoFilter || (row.estado?.text && (row.estado.text.toLowerCase().includes(estadoFilter.toLowerCase()) || row.estado.text === estadoFilter));
          return matchStudent && matchArea && matchAsig && matchEstado;
        });
      }, [rowsAsigByCourse, studentFilter, areaFilter, asigFilter, estadoFilter]);

      // [ChartsSync] fuentes de datos para gráficos
      const chartRowsArea = syncChartsWithFilters ? filteredRowsArea : rowsAreaSource;
      const chartRowsAsig = syncChartsWithFilters ? filteredRowsAsignatura : rowsAsigSource;

      return (
        <div className="w-full">
          <div role="tablist" aria-label="Secciones del Dashboard" onKeyDown={onTabListKeyDown} className="flex gap-2 mb-4">
            <button
              role="tab"
              id="tab-analisis"
              aria-controls="panel-analisis"
              aria-selected={tab === 'analisis'}
              tabIndex={tab === 'analisis' ? 0 : -1}
              className={tab === 'analisis'
                ? 'px-4 py-2 rounded-t-lg font-semibold bg-white shadow'
                : 'px-4 py-2 rounded-t-lg font-semibold bg-gray-200'}
              onClick={() => setTab('analisis')}
            >
              Análisis
            </button>

            <button
              role="tab"
              id="tab-graficos"
              aria-controls="panel-graficos"
              aria-selected={tab === 'graficos'}
              tabIndex={tab === 'graficos' ? 0 : -1}
              className={tab === 'graficos'
                ? 'px-4 py-2 rounded-t-lg font-semibold bg-white shadow'
                : 'px-4 py-2 rounded-t-lg font-semibold bg-gray-200'}
              onClick={() => setTab('graficos')}
            >
              Gráficos
            </button>

            <button
              role="tab"
              id="tab-consultas"
              aria-controls="panel-consultas"
              aria-selected={tab === 'consultas'}
              tabIndex={tab === 'consultas' ? 0 : -1}
              className={tab === 'consultas'
                ? 'px-4 py-2 rounded-t-lg font-semibold bg-white shadow'
                : 'px-4 py-2 rounded-t-lg font-semibold bg-gray-200'}
              onClick={() => setTab('consultas')}
            >
              Consultas/Reportes Rápidos
            </button>
          </div>

          <div className="bg-white rounded-lg shadow p-4">
            {tab === 'analisis' && (
              <div role="tabpanel" id="panel-analisis" aria-labelledby="tab-analisis">
                <DashboardView
                  data={dataForAnalysis}
                  onReset={onReset}
                  fileName={fileName}
                  derived={derived}
                  // Pass down lifted state and setters
                  filters={{ courseFilterDV, studentFilter, areaFilter, asigFilter, estadoFilter }}
                  setFilters={{ setCourseFilterDV, setStudentFilter, setAreaFilter, setAsigFilter, setEstadoFilter }}
                  // Pass down calculated rows
                  filteredRowsArea={filteredRowsArea}
                  filteredRowsAsignatura={filteredRowsAsignatura}
                />
              </div>
            )}
            {tab === 'graficos' && (
              <div role="tabpanel" id="panel-graficos" aria-labelledby="tab-graficos">
                {/* [ChartsSync] toggle en UI de Gráficos */}
                <div className="flex justify-end mb-4">
                  <label className="inline-flex items-center gap-2 text-sm">
                    <input type="checkbox"
                          className="rounded"
                          checked={syncChartsWithFilters}
                          onChange={e => setSyncChartsWithFilters(e.target.checked)} />
                    Sincronizar con filtros de Análisis
                  </label>
                </div>
                <DashboardCharts
                  rowsArea={chartRowsArea}
                  rowsAsignatura={chartRowsAsig}
                />
              </div>
            )}
            {tab === 'consultas' && (
              <div role="tabpanel" id="panel-consultas" aria-labelledby="tab-consultas">
                <QuickReportsView data={dashboardData} />
              </div>
            )}
          </div>
        </div>
      );
    }
    // =============================
    // Componente Consultas/Reportes Rápidos
    // =============================
    function QuickReportsView({ data }) {
      console.time('render:QuickReportsView');
      const [courseFilter, setCourseFilter] = useState('ALL');

      const courseOptions = useMemo(() => {
        if (!Array.isArray(data)) return ['ALL'];
        // [Fix-CURSO] conjunto de cursos consistente
        const getCurso = (r) => r.CURSO ?? r.curso;
        const set = new Set(data.map(getCurso).filter(Boolean));
        return ['ALL', ...Array.from(set)];
      }, [data]);

      const filteredData = useMemo(() => {
        if (!Array.isArray(data)) return [];
        if (courseFilter === 'ALL') return data;
        return data.filter(s => (s.CURSO ?? s.curso) === courseFilter);
      }, [data, courseFilter]);

      const areaLabels = useMemo(() => Array.from(new Set(filteredData.flatMap(s => Object.keys(s.areas)))), [filteredData]);

      const lowAverages = useMemo(() => areaLabels.map(area => {
        const students = filteredData.map(s => ({
          name: s.name,
          prom: s.areas[area]?.areaStats?.promedioActual ?? null
        })).filter(s => typeof s.prom === 'number' && s.prom < 3.0);
        students.sort((a,b) => a.prom-b.prom);
        return { area, students };
      }).filter(a => a.students.length > 0), [filteredData, areaLabels]);

      const topLost = useMemo(() => {
        const lostAreas = filteredData.map(s => ({
          name: s.name,
          perdidas: Object.values(s.areas).filter(a => a.areaStats?.estado?.text==='Perdido').length
        }));
        lostAreas.sort((a,b)=>b.perdidas-a.perdidas);
        return lostAreas.filter(s=>s.perdidas>0);
      }, [filteredData]);

      const topRisk = useMemo(() => {
        const riskAreas = filteredData.map(s => ({
          name: s.name,
          riesgo: Object.values(s.areas).filter(a => a.areaStats?.estado?.text==='En riesgo').length
        }));
        riskAreas.sort((a,b)=>b.riesgo-a.riesgo);
        return riskAreas.filter(s=>s.riesgo>0);
      }, [filteredData]);

      const topRecup = useMemo(() => {
        const recupAreas = filteredData.map(s => ({
          name: s.name,
          recup: Object.values(s.areas).filter(a => a.areaStats?.estado?.text==='Recuperable').length
        }));
        recupAreas.sort((a,b)=>b.recup-a.recup);
        return recupAreas.filter(s=>s.recup>0);
      }, [filteredData]);

      const areaRisk = useMemo(() => areaLabels.map(area => {
        const riesgo = filteredData.filter(s => s.areas[area]?.areaStats?.estado?.text==='En riesgo').length;
        return { area, riesgo };
      }).filter(a=>a.riesgo>0).sort((a,b)=>b.riesgo-a.riesgo), [filteredData, areaLabels]);

      const { topGlobal, worstGlobal } = useMemo(() => {
        const globalProms = filteredData.map(s => {
          const proms = Object.values(s.areas).map(a => a.areaStats?.promedioActual).filter(v=>typeof v==='number');
          const prom = proms.length ? proms.reduce((a,b)=>a+b,0)/proms.length : null;
          return { name: s.name, prom };
        }).filter(s=>typeof s.prom==='number');
        globalProms.sort((a,b)=>b.prom-a.prom);
        const topGlobal = globalProms.slice(0, 10);
        const worstGlobal = globalProms.filter(s=>s.prom < 3.0).sort((a,b)=>a.prom-b.prom);
        return { topGlobal, worstGlobal };
      }, [filteredData]);

      useEffect(() => {
        console.timeEnd('render:QuickReportsView');
      });

      return (
        <div className="space-y-8">
          <h2 className="text-xl font-bold mb-4 text-blue-700">Consultas y Reportes Rápidos</h2>
          <div className="flex items-center gap-2 mb-4">
            <label className="text-sm font-medium">Curso:</label>
            <select
              className="border rounded px-2 py-1 text-sm"
              value={courseFilter}
              onChange={(e) => setCourseFilter(e.target.value)}
            >
              {courseOptions.map(opt => (
                <option key={opt} value={opt}>{opt === 'ALL' ? 'Todos' : opt}</option>
              ))}
            </select>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-blue-600">Promedios más bajos por Área</h3>
              <div className="max-h-64 overflow-auto pr-2">
                {lowAverages.map(a=>(
                  <div key={a.area} className="mb-3">
                    <div className="font-bold text-sm mb-1">{a.area}</div>
                    <ul className="text-xs">
                      {a.students.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-red-600">{s.prom.toFixed(2)}</span></li>))}
                    </ul>
                  </div>
                ))}
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-red-600">Estudiantes con más Áreas Perdidas</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {topLost.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-red-600">{s.perdidas}</span> áreas</li>))}
                </ul>
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-yellow-600">Estudiantes con más Áreas en Riesgo</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {topRisk.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-yellow-600">{s.riesgo}</span> áreas</li>))}
                </ul>
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-blue-600">Estudiantes con más Áreas Recuperables</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {topRecup.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-blue-600">{s.recup}</span> áreas</li>))}
                </ul>
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-yellow-700">Áreas con más estudiantes en riesgo</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {areaRisk.map(a=>(<li key={a.area}>{a.area}: <span className="font-semibold text-yellow-700">{a.riesgo}</span> estudiantes</li>))}
                </ul>
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-green-700">Top estudiantes con mejor desempeño global</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {topGlobal.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-green-700">{s.prom.toFixed(2)}</span></li>))}
                </ul>
              </div>
            </div>
            <div className="bg-white border rounded-xl p-4 shadow">
              <h3 className="font-semibold mb-2 text-red-700">Top estudiantes con peor desempeño global</h3>
              <div className="max-h-64 overflow-auto pr-2">
                <ul className="text-xs">
                  {worstGlobal.map(s=>(<li key={s.name}>{s.name}: <span className="font-semibold text-red-700">{s.prom.toFixed(2)}</span></li>))}
                </ul>
              </div>
            </div>
          </div>
        </div>
      );
    }
    // ...resto del código React...
  </script>
  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, "Noto Sans", 'Apple Color Emoji', 'Segoe UI Emoji'; }
    .highlight-unitary { background-color: #f0f9ff; border-left: 3px solid #3b82f6; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">
  <header class="w-full bg-gradient-to-r from-blue-900 via-yellow-400 to-green-700 shadow-lg py-3 px-4 flex items-center justify-between">
    <div class="flex items-center gap-4">
  <img src="escudo-el-carmen.jpg" alt="Escudo IE El Carmen" class="rounded-full border-2 border-white shadow-md bg-white object-cover w-12 h-12" />
      <div>
        <h1 class="text-2xl md:text-3xl font-bold text-white drop-shadow">IE EL CARMEN</h1>
        <span class="text-xs md:text-sm text-white/80 font-semibold">Dashboard Institucional</span>
      </div>
    </div>
  </header>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, Fragment, useMemo } = React;

    // ==============================
    // Iconos (Lucide-like minimal)
    // ==============================
    const Icon = ({path, className}) => (
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        {path}
      </svg>
    );
    const UploadCloudIcon = (p) => <Icon {...p} path={<Fragment><path d="M4 14.9A7 7 0 1 1 15.7 8h1.8A4.5 4.5 0 0 1 20 16.2"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></Fragment>} />
    const CheckCircleIcon = (p) => <Icon {...p} path={<Fragment><path d="M22 11.08V12A10 10 0 1 1 16.07 2.86"/><polyline points="22 4 12 14.01 9 11.01"/></Fragment>} />
    const AlertTriangleIcon = (p) => <Icon {...p} path={<Fragment><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></Fragment>} />
    const InfoIcon = (p) => <Icon {...p} path={<Fragment><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></Fragment>} />
    const DatabaseIcon = (p) => <Icon {...p} path={<Fragment><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14a9 3 0 0 0 18 0V5"/><path d="M3 12a9 3 0 0 0 18 0"/></Fragment>} />
    const BarChartIcon = (p) => <Icon {...p} path={<Fragment><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></Fragment>} />

    // ==============================================
    // Utilidades: normalización y helpers del parser
    // ==============================================
    const textNormalize = (v) => (typeof v === 'string' ? v.trim() : v);
    const toUpperSafe = (v) => (v == null ? '' : String(v).trim().toUpperCase());

    const removeDiacritics = (str) => (str || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '');

    const normalizeName = (s) => {
      let v = toUpperSafe(s);
      v = removeDiacritics(v);
      return v.replace(/\s+/g, ' ').trim();
    }

    const normalizeAsignatura = (s) => {
      const v = normalizeName(s);
      // Corrected regex: escaped dot and word boundary
      if (/^(DEF(\.|INIT)?|DEFINITIVA|DEF AREA|AREA DEF)\b/.test(v)) return 'DEF';
      return v;
    };

    const normalizeArea = (s) => normalizeName(s);
    const normalizeComponente = (s) => {
      let v = toUpperSafe(s);
      v = removeDiacritics(v);
      v = v.replace(/\s+/g, '');
      if (/^(P1|1P|PRIMERO|PER1|PERIODO1)$/i.test(v)) return 'P1';
      if (/^(P2|2P|SEGUNDO|PER2|PERIODO2)$/i.test(v)) return 'P2';
      if (/^(P3|3P|TERCERO|PER3|PERIODO3)$/i.test(v)) return 'P3';
      if (/^(A|ACUMULADO|ACUM)$/.test(v)) return 'A';
      const defPx = v.match(/^DEF(P[123])$/);
      if (defPx) return defPx[1];
      return v || '';
    };

    // ========================================
    // (3) PARSER de encabezados (robustecido)
    // ========================================
    const profilingLogic = {
      parseHeaders: (headerRows, log) => {
        // Aseguramos que cada fila de encabezado tenga el mismo largo
        const maxLen = Math.max(...headerRows.map(r => r.length));
        const [rawAreas, rawAsignaturas, rawComponentes] = headerRows.map(row => {
          const fullRow = [...row];
          while (fullRow.length < maxLen) fullRow.push(undefined);
          return fullRow;
        });
        log.push({ level: 'info', message: `Filas de encabezado detectadas: ${headerRows.length}` });

        // 1. Forward fill en Áreas
        for (let i = 1; i < rawAreas.length; i++) {
          if (!textNormalize(rawAreas[i])) rawAreas[i] = rawAreas[i - 1];
        }
        log.push({ level: 'info', message: `Áreas después de forward-fill: ${JSON.stringify(rawAreas)}` });

        // 2. Forward fill contextual en Asignaturas
        for (let i = 1; i < rawAsignaturas.length; i++) {
          if (!textNormalize(rawAsignaturas[i]) && textNormalize(rawAreas[i]) === textNormalize(rawAreas[i - 1])) {
            rawAsignaturas[i] = rawAsignaturas[i - 1];
          }
        }
        log.push({ level: 'info', message: `Asignaturas después de forward-fill contextual: ${JSON.stringify(rawAsignaturas)}` });

        // 3. Relleno de Asignatura con Área para áreas 1:1
        for (let i = 0; i < rawAsignaturas.length; i++) {
          if (!textNormalize(rawAsignaturas[i])) {
            rawAsignaturas[i] = rawAreas[i];
          }
        }
        log.push({ level: 'info', message: `Asignaturas después de relleno 1:1: ${JSON.stringify(rawAsignaturas)}` });

        // 4. Estructurar y normalizar, OMITIENDO las primeras dos columnas (No, Estudiante)
        let structuredHeaders = rawComponentes.map((comp, i) => ({
          index: i,
          area: normalizeArea(rawAreas[i]),
          asignatura: normalizeAsignatura(rawAsignaturas[i]),
          componente: normalizeComponente(comp),
          raw: { area: rawAreas[i], asignatura: rawAsignaturas[i], componente: comp }
        }));
        log.push({ level: 'info', message: `structuredHeaders before slice(2): ${JSON.stringify(structuredHeaders)}` });

        // Omitimos las dos primeras columnas (No, Estudiante)
        structuredHeaders = structuredHeaders.slice(2);
        log.push({ level: 'info', message: `structuredHeaders after slice(2): ${JSON.stringify(structuredHeaders)}` });

        // Filtramos solo las cabeceras válidas
        structuredHeaders = structuredHeaders.filter(h => h.area && h.asignatura);
        log.push({ level: 'info', message: `structuredHeaders after filter: ${JSON.stringify(structuredHeaders)}` });

        log.push({ level: 'info', message: `Cabeceras estructuradas y normalizadas generadas.` });
        return structuredHeaders;
      },
      getCountsFromSource: (headers) => {
        console.log("getCountsFromSource: headers received:", headers); // Added log
        const areas = new Set();
        const asignaturas = new Set();
        headers.forEach(h => {
          if (h.area && h.area !== 'META') {
            areas.add(h.area);
          }
          // FIX: Contar nombres de asignaturas únicas, excluyendo 'DEF' y columnas 'META'.
          if (h.asignatura && h.asignatura !== 'DEF' && h.area !== 'META') {
            asignaturas.add(h.asignatura);
          }
        });
        console.log("getCountsFromSource: unique areas:", Array.from(areas)); // Added log
        console.log("getCountsFromSource: unique asignaturas:", Array.from(asignaturas)); // Added log
        return { areaCount: areas.size, asignaturaCount: asignaturas.size };
      }
    };

    // ================================================
    // (4) Limpieza, estructura, y síntesis de DEF 1:1
    // ================================================
    const cleaningLogic = {
      normalizeText: (t) => (typeof t === 'string' ? t.trim().replace(/\s+/g, ' ') : t),
      convertToNumber: (value) => {
        if (value === null || value === undefined) return null;
        let s = String(value).trim();
        if (!s || s === '—' || s.toUpperCase() === 'NA') return null;
        const num = parseFloat(s.replace(',', '.'));
        return Number.isFinite(num) ? num : null;
      },
      structureData: (profile, log) => {
        const { tableHeaders, tableData } = profile;
        const structured = [];
        const studentNames = new Set();

        tableData.forEach((row, rowIndex) => {
          const studentName = cleaningLogic.normalizeText(row[1]);
          if (!studentName) {
            log.push({ type: 'error', message: `Fila ${rowIndex + 4}: Estudiante sin nombre. Fila omitida.` });
            return;
          }
          if (studentNames.has(studentName)) {
            log.push({ type: 'warning', message: `Estudiante duplicado: "${studentName}". Se procesará, pero revise duplicidad.` });
          }
          studentNames.add(studentName);

          const student = { id: cleaningLogic.normalizeText(row[0]), name: studentName, areas: {} };

          tableHeaders.forEach(h => {
            const { area, asignatura, componente, index } = h;
            if (!area || area === 'META' || !asignatura || !componente) return;
            if (!student.areas[area]) student.areas[area] = { asignaturas: {}, DEF: {} };

            let note = cleaningLogic.convertToNumber(row[index]);
            // Si hay texto no numérico visible
            if (row[index] !== null && String(row[index]).trim() !== '' && note === null) {
              log.push({ type: 'warning', message: `'${studentName}': Valor no numérico '${row[index]}' en ${area}>${asignatura}>${componente} → nulo.` });
            }
            // Validación de rango (BUG FIX: forzar note=null cuando esté fuera de 0..5)
            if (note !== null && (note < 0 || note > 5)) {
              log.push({ type: 'error', message: `'${studentName}': Nota fuera de rango '${row[index]}' en ${area}>${asignatura}>${componente} → nulo.` });
              note = null; // <-- corrección clave
            }

            // Registrar
            if (asignatura === 'DEF') {
              if (['P1','P2','P3'].includes(componente)) student.areas[area].DEF[componente] = note;
            } else {
              if (!student.areas[area].asignaturas[asignatura]) student.areas[area].asignaturas[asignatura] = {};
              if (['P1','P2','P3'].includes(componente)) student.areas[area].asignaturas[asignatura][componente] = note;
            }
          });

          // Síntesis de DEF para áreas unitarias
          Object.entries(student.areas).forEach(([areaName, areaData]) => {
            const hasExplicitDEF = Object.values(areaData.DEF).some(v => v !== null);
            if (!hasExplicitDEF) {
              const mainAsignatura = areaData.asignaturas[areaName];
              if (mainAsignatura) {
                areaData.DEF = { ...mainAsignatura };
                log.push({ type: 'info', message: `Área unitaria "${areaName}": DEF sintetizado desde asignatura.` });
              }
            }
          });

          structured.push(student);
        });

        return { structuredData: structured, log };
      }
    };

    // ======================================
    // (5) Cálculos y proyección P4 mínima
    // ======================================
    const calculationLogic = {
      getStatus: (p4Min) => {
        if (p4Min === null) return { text: 'N/A', color: 'gray' };
        if (p4Min >= 5.0) return { text: 'Perdido', color: 'red' };
        if (p4Min >= 4.0) return { text: 'En riesgo', color: 'yellow' };
        if (p4Min >= 3.0) return { text: 'Recuperable', color: 'blue' };
        if (p4Min >= 1.0) return { text: 'Ganable', color: 'cyan' };
        return { text: 'Ganado', color: 'green' };
      },
      calcPromYMin: (p1, p2, p3) => {
        const vals = [p1, p2, p3].filter(v => v !== null && v !== undefined);
        if (vals.length === 0) return { promedioActual: null, p4Min: null, estado: { text: 'N/A', color: 'gray' } };
        const sum = vals.reduce((a,b)=>a+b, 0);
        const promedioActual = sum / vals.length; // promedio de los presentes (mejor lectura)
        let p4Min = 12 - (p1 ?? 0) - (p2 ?? 0) - (p3 ?? 0); // mantengo criterio institucional (sumatoria ≥ 12)
        if (p4Min < 0) p4Min = 0;
        if (!Number.isFinite(p4Min)) p4Min = null;
        return { promedioActual, p4Min, estado: calculationLogic.getStatus(p4Min) };
      },
      performAllCalculations: (structuredData) => structuredData.map(student => {
        const out = { ...student, areas: {} };
        Object.entries(student.areas).forEach(([areaName, areaData]) => {
          // Asignaturas
          const nuevas = {};
          Object.entries(areaData.asignaturas).forEach(([asigName, asigData]) => {
            const { promedioActual, p4Min, estado } = calculationLogic.calcPromYMin(asigData.P1, asigData.P2, asigData.P3);
            nuevas[asigName] = { ...asigData, promedioActual, p4Min, estado };
          });
          // Área (DEF)
          const def = areaData.DEF || {};
          const areaStats = calculationLogic.calcPromYMin(def.P1, def.P2, def.P3);
          out.areas[areaName] = { ...areaData, asignaturas: nuevas, areaStats };
        });
        return out;
      })
    };

    // ======================================
    // (6.1) Importador multi-hojas por archivo
    // ======================================
    const makeCourseName = (fileBase, sheetName) => {
      const s = String(sheetName || '').trim();
      return s ? `${fileBase} - ${s}` : fileBase;
    };

    const ensureUniqueName = (existingCourses, desired) => {
      const exists = (name) => existingCourses.some(c => c.name === name);
      if (!exists(desired)) return desired;
      let i = 2;
      while (exists(`${desired} (${i})`)) i++;
      return `${desired} (${i})`;
    };

    const importWorkbookToProfiles = (wb, fileName) => {
      const out = [];
      const fileBase = String(fileName || '').replace(/\.(xlsx|xls|csv)$/i, '');
      (wb.SheetNames || []).forEach((sheetName) => {
        try {
          const ws = wb.Sheets[sheetName];
          if (!ws) return;
          const data = XLSX.utils.sheet_to_json(ws, { header: 1, blankrows: false });
          if (!data || data.length < 4) return; // 3 header rows + data

          // Normalizar las 3 filas de encabezados al mismo largo
          const maxCols = Math.max(...data.slice(0,3).map(r => r.length));
          const headerRows = data.slice(0,3).map(row => {
            const full = [...row];
            while (full.length < maxCols) full.push(undefined);
            return full;
          });
          const tableData = data.slice(3);

          out.push({ fileName, sheetName, headerRows, tableData, courseBase: fileBase });
        } catch (e) {
          console.warn('Hoja omitida por error:', sheetName, e);
        }
      });
      return out;
    };

    // ======================================
    // (6) Componentes de Interfaz
    // ======================================
    const StatusBadge = ({ status }) => {
      const color = {
        red: 'bg-red-200 text-red-900 border border-red-400',
        yellow: 'bg-yellow-100 text-yellow-900 border border-yellow-400',
        blue: 'bg-blue-100 text-blue-900 border border-blue-400',
        cyan: 'bg-cyan-100 text-cyan-900 border border-cyan-400',
        green: 'bg-green-100 text-green-900 border border-green-400',
        gray: 'bg-gray-100 text-gray-800 border border-gray-300'
      }[status.color] || 'bg-gray-100 text-gray-800 border border-gray-300';
      const icon = {
        red: <AlertTriangleIcon className="inline w-4 h-4 mr-1" />,
        yellow: <InfoIcon className="inline w-4 h-4 mr-1" />,
        blue: <BarChartIcon className="inline w-4 h-4 mr-1" />,
        cyan: <CheckCircleIcon className="inline w-4 h-4 mr-1" />,
        green: <CheckCircleIcon className="inline w-4 h-4 mr-1" />,
        gray: <InfoIcon className="inline w-4 h-4 mr-1" />
      }[status.color] || null;
      return <span className={`px-2 inline-flex items-center text-xs leading-5 font-semibold rounded-full ${color}`}>{icon}{status.text}</span>;
    };

    const UploadView = ({ onWorkbookProcessed, onLoading }) => {
      const safeLoading = {
        start: (msg) => { try { onLoading?.start?.(msg); } catch {} },
        update: (msg) => { try { onLoading?.update?.(msg); } catch {} },
        stop: () => { try { onLoading?.stop?.(); } catch {} },
      };
      const [pendingFile, setPendingFile] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const inputRef = useRef(null);
      const [overlay, setOverlay] = useState({ visible: false, text: 'Procesando…' });

      const handleSelected = (flist) => {
        if (!flist || flist.length === 0) return;
        const f = flist[0];
        setPendingFile(f);
        if (inputRef.current) inputRef.current.value = '';
      };

      const handleProcessClick = async () => {
        if (!pendingFile) return;

        setOverlay({ visible: true, text: 'Procesando…' });
        await new Promise(resolve => requestAnimationFrame(resolve));

        const f = pendingFile;
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            setOverlay({ visible: true, text: 'Importando libro de Excel…' });
            const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });

            if (!wb.SheetNames || wb.SheetNames.length === 0) {
              setOverlay({ visible: true, text: 'Error: El archivo no contiene hojas.' });
              setTimeout(() => setOverlay({ visible: false, text: 'Procesando…' }), 2000);
              setPendingFile(null);
              return;
            }
            
            setOverlay({ visible: true, text: 'Analizando hojas…' });
            const profiles = importWorkbookToProfiles(wb, f.name);

            if (profiles.length === 0) {
              setOverlay({ visible: true, text: 'Error: Estructura inválida.' });
              setTimeout(() => setOverlay({ visible: false, text: 'Procesando…' }), 2000);
              setPendingFile(null);
              return;
            }
            
            setOverlay({ visible: true, text: 'Consolidando datos…' });
            onWorkbookProcessed(profiles);
          } catch (err) {
            console.error("Error processing file:", err);
            setOverlay({ visible: true, text: 'Error al procesar. Revise el archivo.' });
            setTimeout(() => setOverlay({ visible: false, text: 'Procesando…' }), 2000);
            setPendingFile(null);
          }
        };

        reader.onerror = () => {
          setOverlay({ visible: true, text: 'Error al leer el archivo.' });
          setTimeout(() => setOverlay({ visible: false, text: 'Procesando…' }), 2000);
          setPendingFile(null);
        };

        reader.readAsArrayBuffer(f);
      };

      const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleSelected(e.dataTransfer.files); };
      const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(e.type === 'dragenter' || e.type === 'dragover'); };

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-6">
          <div className="w-full max-w-3xl">
            <h1 className="text-3xl font-bold text-center">Dashboard Académico</h1>
            <p className="text-center text-gray-600 mb-6">Sube un archivo de Excel para analizar las notas (soporte multi-hojas).</p>
            <div className="space-y-4">
              <div
                onDrop={handleDrop}
                onDragEnter={handleDrag}
                onDragOver={handleDrag}
                onDragLeave={handleDrag}
                className={`relative flex flex-col items-center justify-center w-full p-10 border-2 border-dashed rounded-xl cursor-pointer transition ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-white hover:border-gray-400'}`}
                onClick={() => inputRef.current?.click()}
              >
                <div className="flex flex-col items-center gap-2">
                  <div className="w-10 h-10 rounded-full border-2 border-gray-300 flex items-center justify-center">
                    <span className="text-sm font-mono">XLSX</span>
                  </div>
                  <p className="font-semibold text-gray-800">Arrastra y suelta un archivo aquí</p>
                  <p className="text-sm text-gray-500">o</p>
                  <button
                    type="button"
                    className="mt-1 inline-flex items-center px-4 py-2 rounded-md text-white bg-blue-600 hover:bg-blue-700"
                  >
                    Seleccionar archivo
                  </button>
                  <p className="text-xs text-gray-500 mt-2">Cada hoja se importará como curso.</p>
                </div>

                {/* input real */}
                <input
                  ref={inputRef}
                  type="file"
                  className="hidden"
                  onChange={(e)=>handleSelected(e.target.files)}
                  accept=".xlsx,.xls,.csv"
                  aria-label="Seleccionar archivo Excel o CSV para importar cursos"
                />
              </div>
              {pendingFile && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium text-blue-800">Archivo seleccionado:</p>
                    <p className="text-sm text-blue-700">{pendingFile.name}</p>
                  </div>
                  <button
                    onClick={handleProcessClick}
                    className="px-4 py-2 rounded-md text-white bg-green-600 hover:bg-green-700"
                  >
                    Procesar archivo
                  </button>
                </div>
              )}
            </div>
          </div>
          {overlay.visible && (
            <div className="fixed inset-0 z-50 bg-white/70 backdrop-blur-sm flex items-center justify-center" role="status" aria-live="assertive">
              <div className="flex flex-col items-center">
                <div className="animate-spin h-10 w-10 rounded-full border-4 border-blue-300 border-t-blue-600"></div>
                <p className="mt-3 font-semibold text-blue-800">{overlay.text}</p>
              </div>
            </div>
          )}
        </div>
      );
    };

    const ValidationReportView = ({ report, onReset, onConfirm }) => {
      const { fileName, qualityIssues } = report;
      const errorCount = qualityIssues.filter(i => i.type === 'error').length;
      return (
        <div className="max-w-7xl mx-auto px-6 py-8">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold">Reporte de Calidad de Datos</h1>
              <p className="text-gray-600">Archivo: <span className="font-semibold text-blue-600">{fileName}</span></p>
            </div>
            <div className="mt-4 md:mt-0 space-x-2">
              <button onClick={onReset} className="px-4 py-2 rounded-md border">Cargar otro</button>
              <button onClick={onConfirm} disabled={errorCount>0} className={`px-4 py-2 rounded-md text-white ${errorCount>0?'bg-gray-400 cursor-not-allowed':'bg-green-600 hover:bg-green-700'}`}>{errorCount>0?'Corrija errores':'Continuar'}</button>
            </div>
          </div>

          <div className="bg-white border border-gray-200 rounded-xl p-5">
            <h2 className="text-lg font-semibold mb-2">Log de incidencias</h2>
            {qualityIssues.length===0 ? (
              <div className="flex items-center p-4 rounded-md bg-green-50 text-green-800"><CheckCircleIcon className="w-5 h-5 mr-2"/><p>Sin problemas de calidad.</p></div>
            ) : (
              <div className="space-y-2 max-h-[50vh] overflow-auto">
                {qualityIssues.map((i,idx)=> (
                  <div key={idx} className={`p-3 rounded-md border text-sm ${i.type==='error'?'bg-red-50 border-red-200 text-red-800':'bg-yellow-50 border-yellow-200 text-yellow-800'}`}>
                    {i.type==='error' ? <AlertTriangleIcon className="inline w-4 h-4 mr-1"/> : <InfoIcon className="inline w-4 h-4 mr-1"/>}
                    {i.message}
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    };

    const ReconciliationView = ({ report, onConfirm, onBack, acceptChecks }) => {
      const { sourceCounts, processedCounts, log, fileName } = report;
      const areaDiff = processedCounts.areaCount - sourceCounts.areaCount;
      const asigDiff = processedCounts.asignaturaCount - sourceCounts.asignaturaCount;

      return (
        <div className="max-w-7xl mx-auto px-6 py-8">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-6">
            <div>
              <h1 className="text-2xl font-bold">Reporte de Reconciliación</h1>
              <p className="text-gray-600">Verificación de integridad: <span className="font-semibold text-blue-600">{fileName}</span></p>
            </div>
            <div className="mt-4 md:mt-0 space-x-2">
              <button onClick={onBack} className="px-4 py-2 rounded-md border">Volver</button>
              <button onClick={onConfirm} className="px-4 py-2 rounded-md text-white bg-green-600 hover:bg-green-700">Continuar al Dashboard</button>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="bg-white border border-gray-200 rounded-xl p-5">
              <h2 className="text-lg font-semibold mb-2 flex items-center"><DatabaseIcon className="w-5 h-5 mr-2 text-blue-600"/>Conteo</h2>
              <dl className="text-sm space-y-3">
                <div>
                  <dt className="text-gray-500">Áreas únicas</dt>
                  <dd className="flex items-baseline justify-between"><span className="text-2xl font-semibold">{processedCounts.areaCount} <span className="text-sm">de</span> {sourceCounts.areaCount}</span><span className={`px-2 py-1 text-xs font-bold rounded-full ${areaDiff===0?'bg-green-100 text-green-800':'bg-red-100 text-red-800'}`}>{areaDiff===0?'OK':areaDiff}</span></dd>
                </div>
                <div>
                  <dt className="text-gray-500">Asignaturas únicas</dt>
                  <dd className="flex items-baseline justify-between"><span className="text-2xl font-semibold">{processedCounts.asignaturaCount} <span className="text-sm">de</span> {sourceCounts.asignaturaCount}</span><span className={`px-2 py-1 text-xs font-bold rounded-full ${asigDiff===0?'bg-green-100 text-green-800':'bg-red-100 text-red-800'}`}>{asigDiff===0?'OK':asigDiff}</span></dd>
                </div>
                <div>
                  <dt className="text-gray-500">Estudiantes</dt>
                  <dd className="text-2xl font-semibold">{processedCounts.studentCount}</dd>
                </div>
              </dl>
            </div>

            <div className="lg:col-span-2 bg-white border border-gray-200 rounded-xl p-5">
              <h2 className="text-lg font-semibold mb-2">Log de procesamiento</h2>
              {log.length===0 ? (
                <div className="flex items-center p-4 rounded-md bg-green-50 text-green-800"><CheckCircleIcon className="w-5 h-5 mr-2"/><p>Sin incidencias.</p></div>
              ) : (
                <div className="space-y-2 max-h-[50vh] overflow-auto">
                  {log.map((i,idx)=> (
                    <div key={idx} className={`p-3 rounded-md border text-sm ${i.type==='error'?'bg-red-50 border-red-200 text-red-800':'bg-yellow-50 border-yellow-200 text-yellow-800'}`}>
                      {i.type==='error' ? <AlertTriangleIcon className="inline w-4 h-4 mr-1"/> : <InfoIcon className="inline w-4 h-4 mr-1"/>}
                      {i.message}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* (6) Validación contra criterios de aceptación */}
          <div className="mt-6 bg-white border border-gray-200 rounded-xl p-5">
            <h2 className="text-lg font-semibold mb-3">Validación (Criterios de Aceptación)</h2>
            <ul className="text-sm space-y-2">
              <li>1. Propagación <em>DEF</em> a P1/P2/P3: <span className={`px-2 py-1 rounded ${acceptChecks.defPropagation? 'bg-green-100 text-green-800':'bg-red-100 text-red-800'}`}>{acceptChecks.defPropagation? 'OK':'FALTA'}</span></li>
              <li>2. Áreas 1:1 visibles (ej. INGLÉS, INFORMÁTICA): <span className={`px-2 py-1 rounded ${acceptChecks.singleArea? 'bg-green-100 text-green-800':'bg-red-100 text-red-800'}`}>{acceptChecks.singleArea? 'OK':'FALTA'}</span></li>
              <li>3. Integridad de render (sin secciones omitidas): <span className={`px-2 py-1 rounded ${acceptChecks.renderOK? 'bg-green-100 text-green-800':'bg-red-100 text-red-800'}`}>{acceptChecks.renderOK? 'OK':'FALTA'}</span></li>
            </ul>
          </div>
        </div>
      );
    };

    const DashboardView = ({ data, onReset, fileName, derived, filters, setFilters }) => {
      console.time('render:DashboardView');
      const { courseFilterDV, studentFilter, areaFilter, asigFilter, estadoFilter } = filters;
      const { setCourseFilterDV, setStudentFilter, setAreaFilter, setAsigFilter, setEstadoFilter } = setFilters;
      const [subtab, setSubtab] = useState('areas');
      const [pageAreas, setPageAreas] = useState(1);
      const [pageAsig, setPageAsig] = useState(1);
      const pageSize = 50;

      const hasDerived = !!(derived && Array.isArray(derived.rowsArea));
      const hasDerivedAsig = !!(derived && Array.isArray(derived.rowsAsignatura));
      const hasDerivedKPIs = !!(derived && Array.isArray(derived.rowsArea) && derived.promGeneral != null && derived.estadoCounts && Array.isArray(derived.areaRiesgo));
      console.debug('[DashboardView] KPIs: using derived?', hasDerivedKPIs);
      const hasActiveFilters = !!(courseFilterDV !== 'ALL' || studentFilter || areaFilter || asigFilter || estadoFilter);

      const showCourseCol = useMemo(() => Array.isArray(data) && data.some(s => !!s?.CURSO), [data]);

      const courseOptionsDV = useMemo(() => {
        const set = new Set(Array.isArray(data) ? data.map(s => s?.CURSO).filter(Boolean) : []);
        return ['ALL', ...Array.from(set)];
      }, [data]);

      const dataForAnalysis = useMemo(() => {
        if (!Array.isArray(data)) return [];
        if (courseFilterDV === 'ALL') return data;
        return data.filter(s => (s?.CURSO || '') === courseFilterDV);
      }, [data, courseFilterDV]);

      useEffect(() => {
        setPageAreas(1);
        setPageAsig(1);
      }, [courseFilterDV, studentFilter, areaFilter, asigFilter, estadoFilter]);

      console.debug('[DashboardView] subtab', subtab, {pageAreas, pageAsig});
      
      const studentList = useMemo(() => Array.from(new Set(dataForAnalysis.map(s => s.name))), [dataForAnalysis]);
      const areaList = useMemo(() => Array.from(new Set(dataForAnalysis.flatMap(s => Object.keys(s.areas)))), [dataForAnalysis]);
      const asigList = useMemo(() => Array.from(new Set(dataForAnalysis.flatMap(s => Object.values(s.areas).flatMap(a => Object.keys(a.asignaturas))))), [dataForAnalysis]);
      const estadoList = useMemo(() => ['Perdido','En riesgo','Recuperable','Ganable','Ganado'], []);

      const getRowClass = (estado) => {
        if (!estado) return '';
        if (estado.text === 'Perdido') return 'bg-red-50';
        if (estado.text === 'En riesgo') return 'bg-yellow-50';
        if (estado.text === 'Recuperable') return 'bg-blue-50';
        if (estado.text === 'Ganable') return 'bg-cyan-50';
        if (estado.text === 'Ganado') return 'bg-green-50';
        return '';
      };

      const rowsAreaSource = useMemo(() => {
        if (hasDerived) {
          return derived.rowsArea;
        }
        // Fallback
        if (!Array.isArray(data)) return [];
        const fallbackRows = [];
        data.forEach(st => {
          Object.entries(st.areas).forEach(([areaName, areaData]) => {
            fallbackRows.push({
              id: `${st.id}-${areaName}`, CURSO: st.CURSO, estudiante: st.name, area: areaName,
              defP1: areaData.DEF?.P1, defP2: areaData.DEF?.P2, defP3: areaData.DEF?.P3,
              promActual: areaData.areaStats?.promedioActual, p4Min: areaData.areaStats?.p4Min, estado: areaData.areaStats?.estado
            });
          });
        });
        return fallbackRows;
      }, [data, hasDerived, derived?.rowsArea]);

      const rowsAreaByCourse = useMemo(() => {
        if (courseFilterDV === 'ALL') return rowsAreaSource;
        return rowsAreaSource.filter(r => (r.CURSO || '') === courseFilterDV);
      }, [rowsAreaSource, courseFilterDV]);

      const filteredRowsArea = useMemo(() => {
        if (!rowsAreaByCourse) return [];
        return rowsAreaByCourse.filter(row => {
            const matchStudent = !studentFilter || row.estudiante.toLowerCase().includes(studentFilter.toLowerCase());
            const matchArea = !areaFilter || row.area.toLowerCase().includes(areaFilter.toLowerCase()) || row.area === areaFilter;
            const matchEstado = !estadoFilter || (row.estado?.text && (row.estado.text.toLowerCase().includes(estadoFilter.toLowerCase()) || row.estado.text === estadoFilter));
            return matchStudent && matchArea && matchEstado;
        });
      }, [rowsAreaByCourse, studentFilter, areaFilter, estadoFilter]);

      const rowsAsigSource = useMemo(() => {
        if (hasDerivedAsig) {
          return derived.rowsAsignatura;
        }
        // Fallback
        if (!Array.isArray(data)) return [];
        const fallbackRows = [];
        data.forEach(st => {
          Object.entries(st.areas).forEach(([areaName, areaData]) => {
            Object.entries(areaData.asignaturas).forEach(([asigName, asigData]) => {
              fallbackRows.push({
                id: `${st.id}-${areaName}-${asigName}`, CURSO: st.CURSO, estudiante: st.name, area: areaName, asignatura: asigName,
                p1: asigData.P1, p2: asigData.P2, p3: asigData.P3,
                promActual: asigData.promedioActual, p4Min: asigData.p4Min, estado: asigData.estado
              });
            });
          });
        });
        return fallbackRows;
      }, [data, hasDerivedAsig, derived?.rowsAsignatura]);

      const rowsAsigByCourse = useMemo(() => {
        if (courseFilterDV === 'ALL') return rowsAsigSource;
        return rowsAsigSource.filter(r => (r.CURSO || '') === courseFilterDV);
      }, [rowsAsigSource, courseFilterDV]);

      const filteredRowsAsignatura = useMemo(() => {
        if (!rowsAsigByCourse) return [];
        return rowsAsigByCourse.filter(row => {
          const matchStudent = !studentFilter || row.estudiante.toLowerCase().includes(studentFilter.toLowerCase());
          const matchArea = !areaFilter || row.area.toLowerCase().includes(areaFilter.toLowerCase()) || row.area === areaFilter;
          const matchAsig = !asigFilter || row.asignatura.toLowerCase().includes(asigFilter.toLowerCase()) || row.asignatura === asigFilter;
          const matchEstado = !estadoFilter || (row.estado?.text && (row.estado.text.toLowerCase().includes(estadoFilter.toLowerCase()) || row.estado.text === estadoFilter));
          return matchStudent && matchArea && matchAsig && matchEstado;
        });
      }, [rowsAsigByCourse, studentFilter, areaFilter, asigFilter, estadoFilter]);

      const kpisBase = useMemo(() => {
        if (hasDerivedKPIs && !hasActiveFilters) {
          const estados = ['Perdido','En riesgo','Recuperable','Ganable','Ganado'];
          const estadoCountsArray = estados.map(e => derived.estadoCounts[e] || 0);
          return { promGeneral: derived.promGeneral.toFixed(2), estadoCounts: estadoCountsArray, areaRiesgo: derived.areaRiesgo, estados };
        }
        return null;
      }, [hasDerivedKPIs, hasActiveFilters, derived]);

      const kpisFiltered = useMemo(() => {
        if (!hasActiveFilters) return null;
        const areaRows = filteredRowsArea || [];
        const estados = ['Perdido','En riesgo','Recuperable','Ganable','Ganado'];

        const proms = areaRows.map(r => r.promActual).filter(v => typeof v === 'number' && !isNaN(v));
        const promGeneral = proms.length ? (proms.reduce((a,b)=>a+b,0)/proms.length).toFixed(2) : 'N/A';

        const byStudent = new Map();
        for (const r of areaRows) {
          const e = r.estado?.text; const name = r.estudiante;
          if (!name || !e) continue;
          if (!byStudent.has(name)) byStudent.set(name, new Set());
          if (estados.includes(e)) byStudent.get(name).add(e);
        }
        const estadoCountsObj = Object.fromEntries(estados.map(s => [s, 0]));
        for (const set of byStudent.values()) for (const s of set) estadoCountsObj[s]++;
        const estadoCounts = estados.map(e => estadoCountsObj[e]);

        const total = new Set(areaRows.map(r => r.estudiante)).size;
        const agg = new Map();
        for (const r of areaRows) {
          const a = r.area; const e = r.estado?.text;
          if (!a) continue;
          if (!agg.has(a)) agg.set(a, {enRiesgo:0, reprobados:0});
          const obj = agg.get(a);
          if (e === 'En riesgo') obj.enRiesgo++;
          if (e === 'Perdido') obj.reprobados++;
        }
        const areaRiesgo = Array.from(agg.entries()).map(([area, v]) => ({ area, enRiesgo: v.enRiesgo, reprobados: v.reprobados, total })).filter(a => a.enRiesgo > 0 || a.reprobados > 0);

        return { promGeneral, estadoCounts, areaRiesgo, estados };
      }, [hasActiveFilters, filteredRowsArea]);

      const kpisFallback = useMemo(() => {
        if (hasDerivedKPIs || hasActiveFilters) return null;
        const allProms = dataForAnalysis.flatMap(st => Object.values(st.areas).map(a => a.areaStats?.promedioActual).filter(v => typeof v === 'number'));
        const promGeneral = allProms.length ? (allProms.reduce((s,v)=>s+v,0)/allProms.length).toFixed(2) : 'N/A';
        const estados = ['Perdido','En riesgo','Recuperable','Ganable','Ganado'];
        const estadoCounts = estados.map(e => dataForAnalysis.filter(st => Object.values(st.areas).some(a => a.areaStats?.estado?.text === e)).length);
        const areaLabels = Array.from(new Set(dataForAnalysis.flatMap(st => Object.keys(st.areas))));
        const areaRiesgo = areaLabels.map(a => {
          const total = dataForAnalysis.length;
          const enRiesgo = dataForAnalysis.filter(st => st.areas[a]?.areaStats?.estado?.text === 'En riesgo').length;
          const reprobados = dataForAnalysis.filter(st => st.areas[a]?.areaStats?.estado?.text === 'Perdido').length;
          return { area: a, enRiesgo, reprobados, total };
        }).filter(a => a.enRiesgo > 0 || a.reprobados > 0);
        return { promGeneral, estadoCounts, areaRiesgo, estados };
      }, [dataForAnalysis, hasDerivedKPIs, hasActiveFilters]);

      const { promGeneral, estadoCounts, areaRiesgo, estados } = kpisBase || kpisFiltered || kpisFallback || { promGeneral: 'N/A', estadoCounts: [0,0,0,0,0], areaRiesgo: [], estados: ['Perdido','En riesgo','Recuperable','Ganable','Ganado'] };
      
      console.debug('[DashboardView] KPIs source', kpisBase ? 'derived' : kpisFiltered ? 'filtered-derived' : 'fallback');

      const pagedRowsAsignatura = useMemo(() => {
          const start = (pageAsig - 1) * pageSize;
          return filteredRowsAsignatura.slice(start, start + pageSize);
      }, [filteredRowsAsignatura, pageAsig]);

      const pagedRowsArea = useMemo(() => {
          const start = (pageAreas - 1) * pageSize;
          return filteredRowsArea.slice(start, start + pageSize);
      }, [filteredRowsArea, pageAreas, pageSize]);

      const totalPagesAsig = Math.ceil(filteredRowsAsignatura.length / pageSize);
      const totalPagesAreas = Math.ceil(filteredRowsArea.length / pageSize);

      useEffect(() => {
        console.timeEnd('render:DashboardView');
      });

      return (
        <div className="max-w-screen-xl mx-auto px-2 md:px-6 py-4 md:py-8 space-y-8">
          {/* Panel KPIs */}
          <div className="bg-white border border-blue-200 rounded-xl p-5 mb-6 shadow flex flex-col md:flex-row md:items-center md:justify-between gap-6">
            <div>
              <h2 className="text-xl font-bold mb-2 text-blue-700">Resumen Académico</h2>
              {fileName && (
                <div className="mb-2 text-xs text-gray-600">Archivo analizado: <span className="font-semibold text-blue-700">{fileName}</span></div>
              )}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <p className="text-xs text-gray-500">Promedio general de notas (áreas):</p>
                  <span className="text-3xl font-bold text-blue-600">{promGeneral}</span>
                </div>
                <div>
                  <p className="text-xs text-gray-500">Porcentaje de estudiantes por estado académico:</p>
                  <table className="text-xs border rounded w-full mt-2">
                    <thead className="bg-gray-100">
                      <tr>
                        <th className="px-2 py-1">Estado</th>
                        <th className="px-2 py-1">Cantidad</th>
                        <th className="px-2 py-1">Porcentaje</th>
                      </tr>
                    </thead>
                    <tbody>
                      {estados.map((e,i)=>(
                        <tr key={e}>
                          <td className="px-2 py-1">{e}</td>
                          <td className="px-2 py-1 text-right">{estadoCounts[i]}</td>
                          <td className="px-2 py-1 text-right">{dataForAnalysis.length>0 ? ((estadoCounts[i]/dataForAnalysis.length)*100).toFixed(1)+'%' : '0%'}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div>
              <p className="text-xs text-gray-500 mb-2">Áreas con mayor riesgo o reprobados:</p>
              <table className="text-xs border rounded w-full">
                <thead className="bg-gray-100">
                  <tr>
                    <th className="px-2 py-1">Área</th>
                    <th className="px-2 py-1">En riesgo</th>
                    <th className="px-2 py-1">Reprobados</th>
                  </tr>
                </thead>
                <tbody>
                  {areaRiesgo.length === 0 ? (
                    <tr><td colSpan={3} className="px-2 py-1 text-center text-gray-400">Sin áreas en riesgo/reprobadas</td></tr>
                  ) : areaRiesgo.map(a=>(
                    <tr key={a.area}>
                      <td className="px-2 py-1">{a.area}</td>
                      <td className="px-2 py-1 text-right">{a.enRiesgo}</td>
                      <td className="px-2 py-1 text-right">{a.reprobados}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            <div className="mt-4 md:mt-0">
              <button onClick={onReset} className="px-4 py-2 rounded-md border bg-gray-50 hover:bg-gray-200 transition">Cargar otro archivo</button>
            </div>
          </div>

          {/* Filtros avanzados */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-4">
            {showCourseCol && (
              <div>
                <label className="block text-xs font-medium text-gray-700">Filtrar por Curso</label>
                <select
                  className="mt-1 w-full border rounded-md p-2"
                  value={courseFilterDV}
                  onChange={(e) => setCourseFilterDV(e.target.value)}
                >
                  {courseOptionsDV.map(opt => (
                    <option key={opt} value={opt}>{opt === 'ALL' ? 'Todos' : opt}</option>
                  ))}
                </select>
              </div>
            )}
            <div>
              <label className="block text-xs font-medium text-gray-700">Filtrar por Estudiante</label>
              <input type="text" className="mt-1 w-full border rounded-md p-2" placeholder="Buscar estudiante..." value={studentFilter} onChange={e=>setStudentFilter(e.target.value)} />
              <select className="mt-2 w-full border rounded-md p-2" value={studentFilter} onChange={e=>setStudentFilter(e.target.value)}>
                <option value="">Todos</option>
                {studentList.map(s => <option key={s}>{s}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700">Filtrar por Área</label>
              <input type="text" className="mt-1 w-full border rounded-md p-2" placeholder="Buscar área..." value={areaFilter} onChange={e=>setAreaFilter(e.target.value)} />
              <select className="mt-2 w-full border rounded-md p-2" value={areaFilter} onChange={e=>setAreaFilter(e.target.value)}>
                <option value="">Todas</option>
                {areaList.map(a => <option key={a}>{a}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700">Filtrar por Asignatura</label>
              <input type="text" className="mt-1 w-full border rounded-md p-2" placeholder="Buscar asignatura..." value={asigFilter} onChange={e=>setAsigFilter(e.target.value)} />
              <select className="mt-2 w-full border rounded-md p-2" value={asigFilter} onChange={e=>setAsigFilter(e.target.value)}>
                <option value="">Todas</option>
                {asigList.map(a => <option key={a}>{a}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700">Filtrar por Estado Académico</label>
              <input type="text" className="mt-1 w-full border rounded-md p-2" placeholder="Buscar estado..." value={estadoFilter} onChange={e=>setEstadoFilter(e.target.value)} />
              <select className="mt-2 w-full border rounded-md p-2" value={estadoFilter} onChange={e=>setEstadoFilter(e.target.value)}>
                <option value="">Todos</option>
                {estadoList.map(e => <option key={e}>{e}</option>)}
              </select>
            </div>
          </div>

          <div role="tablist" aria-label="Vistas de análisis" className="flex gap-2 mb-4 border-b">
              <button role="tab" aria-selected={subtab === 'areas'} onClick={() => setSubtab('areas')} className={`px-4 py-2 font-semibold ${subtab === 'areas' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-500'}`}>Análisis por Área</button>
              <button role="tab" aria-selected={subtab === 'asignaturas'} onClick={() => setSubtab('asignaturas')} className={`px-4 py-2 font-semibold ${subtab === 'asignaturas' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-500'}`}>Análisis por Asignatura</button>
          </div>

          {subtab === 'asignaturas' &&
            <div role="tabpanel">
              <div className="bg-white border border-gray-200 rounded-xl p-2 md:p-5">
                <h2 className="text-lg font-semibold mb-2 flex items-center"><BarChartIcon className="w-5 h-5 mr-2 text-blue-600"/>Análisis por Asignatura</h2>
                <div className="overflow-auto max-h-[60vh] border rounded-lg">
                  <table className="min-w-full divide-y divide-gray-200 text-xs md:text-sm">
                    <thead className="bg-gray-50 sticky top-0 z-10">
                      <tr>
                        {showCourseCol && <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase">Curso</th>}
                        <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase" style={{ minWidth: '120px', maxWidth: '200px' }}>Estudiante</th>
                        <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase">Área</th>
                        <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase">Asignatura</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">P1</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">P2</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">P3</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">Promedio actual</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">P4 mín. (≥3.0)</th>
                        <th className="px-3 py-2 text-center font-medium text-gray-500 uppercase">Estado</th>
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {pagedRowsAsignatura.map(row => (
                        <tr key={`${row.CURSO || 'SINGLE'}-${row.id}`} className={`hover:bg-gray-100 ${getRowClass(row.estado)}`}>
                          {showCourseCol && <td className="px-3 py-3 text-sm text-gray-600">{row.CURSO || ''}</td>}
                          <td className="px-3 py-3 font-medium text-gray-900 align-top border-r" style={{minWidth:'120px',maxWidth:'200px'}}>{row.estudiante}</td>
                          <td className="px-3 py-3 text-sm font-medium text-gray-700">{row.area}</td>
                          <td className="px-3 py-3 text-sm text-gray-600">{row.asignatura}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.p1 === 'number' ? row.p1.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.p2 === 'number' ? row.p2.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.p3 === 'number' ? row.p3.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right font-semibold">{typeof row.promActual === 'number' ? row.promActual.toFixed(2) : 'N/A'}</td>
                          <td className="px-3 py-3 text-sm text-right font-semibold">{typeof row.p4Min === 'number' ? row.p4Min.toFixed(2) : 'N/A'}</td>
                          <td className="px-3 py-3 text-sm text-center"><StatusBadge status={row.estado} /></td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <div className="flex justify-between items-center mt-2 text-xs">
                    <button onClick={() => setPageAsig(p => Math.max(1, p - 1))} disabled={pageAsig === 1} className="px-3 py-1 border rounded disabled:opacity-50">Anterior</button>
                    <span>Página {pageAsig} de {totalPagesAsig} ({filteredRowsAsignatura.length} filas)</span>
                    <button onClick={() => setPageAsig(p => Math.min(totalPagesAsig, p + 1))} disabled={pageAsig >= totalPagesAsig} className="px-3 py-1 border rounded disabled:opacity-50">Siguiente</button>
                </div>
              </div>
            </div>
          }

          {subtab === 'areas' &&
            <div role="tabpanel">
              <div className="bg-white border border-gray-200 rounded-xl p-2 md:p-5">
                <h2 className="text-lg font-semibold mb-2 flex items-center"><DatabaseIcon className="w-5 h-5 mr-2 text-green-600"/>Análisis por Área</h2>
                <div className="overflow-auto max-h-[60vh] border rounded-lg">
                  <table className="min-w-full divide-y divide-gray-200 text-xs md:text-sm">
                    <thead className="bg-gray-50 sticky top-0 z-10">
                      <tr>
                        {showCourseCol && <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase">Curso</th>}
                        <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase" style={{ minWidth: '120px', maxWidth: '200px' }}>Estudiante</th>
                        <th className="px-3 py-2 text-left font-medium text-gray-500 uppercase">Área</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">DEF P1</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">DEF P2</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">DEF P3</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">Promedio actual</th>
                        <th className="px-3 py-2 text-right font-medium text-gray-500 uppercase">P4 mín. (≥3.0)</th>
                        <th className="px-3 py-2 text-center font-medium text-gray-500 uppercase">Estado</th>
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {pagedRowsArea.map(row => (
                        <tr key={`${row.CURSO || 'SINGLE'}-${row.id}`} className={`hover:bg-gray-100 ${getRowClass(row.estado)}`}>
                          {showCourseCol && <td className="px-3 py-3 text-sm text-gray-600">{row.CURSO || ''}</td>}
                          <td className="px-3 py-3 font-medium text-gray-900 align-top border-r" style={{minWidth:'120px',maxWidth:'200px'}}>{row.estudiante}</td>
                          <td className="px-3 py-3 text-sm font-medium text-gray-700">{row.area}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.defP1 === 'number' ? row.defP1.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.defP2 === 'number' ? row.defP2.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right">{typeof row.defP3 === 'number' ? row.defP3.toFixed(2) : '-'}</td>
                          <td className="px-3 py-3 text-sm text-right font-semibold">{typeof row.promActual === 'number' ? row.promActual.toFixed(2) : 'N/A'}</td>
                          <td className="px-3 py-3 text-sm text-right font-semibold">{typeof row.p4Min === 'number' ? row.p4Min.toFixed(2) : 'N/A'}</td>
                          <td className="px-3 py-3 text-sm text-center"><StatusBadge status={row.estado} /></td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                 <div className="flex justify-between items-center mt-2 text-xs">
                    <button onClick={() => setPageAreas(p => Math.max(1, p - 1))} disabled={pageAreas === 1} className="px-3 py-1 border rounded disabled:opacity-50">Anterior</button>
                    <span>Página {pageAreas} de {totalPagesAreas} ({filteredRowsArea.length} filas)</span>
                    <button onClick={() => setPageAreas(p => Math.min(totalPagesAreas, p + 1))} disabled={pageAreas >= totalPagesAreas} className="px-3 py-1 border rounded disabled:opacity-50">Siguiente</button>
                </div>
              </div>
            </div>
          }
        </div>
      );
    };

    // ======================================
    // (7) Dataset de prueba + auto-validación
    // ======================================
    const buildSampleProfile = () => {
      // Encabezados (3 filas): Área, Asignatura/DEF, Componente
      // Dataset extendido para incluir áreas compuestas y unitarias según lo solicitado.
      const areas = [
        'No','Nombre',
        'MATEMATICAS','MATEMATICAS','MATEMATICAS', 'MATEMATICAS','MATEMATICAS','MATEMATICAS', 'MATEMATICAS','MATEMATICAS','MATEMATICAS', // Area Compuesta
        'CIENCIAS SOCIALES','CIENCIAS SOCIALES','CIENCIAS SOCIALES', 'CIENCIAS SOCIALES','CIENCIAS SOCIALES','CIENCIAS SOCIALES', 'CIENCIAS SOCIALES','CIENCIAS SOCIALES','CIENCIAS SOCIALES', // Area Compuesta
        'CIENCIAS NATURALES Y EDUCACION AMBIENTAL','CIENCIAS NATURALES Y EDUCACION AMBIENTAL','CIENCIAS NATURALES Y EDUCACION AMBIENTAL', 'CIENCIAS NATURALES Y EDUCACION AMBIENTAL','CIENCIAS NATURALES Y EDUCACION AMBIENTAL','CIENCIAS NATURALES Y EDUCACION AMBIENTAL', // Area Compuesta
        'HUMANIDADES','HUMANIDADES','HUMANIDADES', 'HUMANIDADES','HUMANIDADES','HUMANIDADES', // Area Compuesta
        'ÉTICA Y VALORES','ÉTICA Y VALORES','ÉTICA Y VALORES', // Area Unitaria
        'EDUCACION ARTISTICA','EDUCACION ARTISTICA','EDUCACION ARTISTICA', // Area Unitaria
        'EDUCACION FISICA RECREACION Y DEPORTE','EDUCACION FISICA RECREACION Y DEPORTE','EDUCACION FISICA RECREACION Y DEPORTE', // Area Unitaria
        'EDUCACION RELIGIOSA','EDUCACION RELIGIOSA','EDUCACION RELIGIOSA', // Area Unitaria
        'INGLES','INGLES','INGLES', // Area Unitaria
        'INFORMÁTICA','INFORMÁTICA','INFORMÁTICA', // Area Unitaria
        'EMPRENDIMIENTO','EMPRENDIMIENTO','EMPRENDIMIENTO' // Area Unitaria
      ];
      const asign = [
        'No','Nombre',
        'ESTADISTICA','ESTADISTICA','ESTADISTICA', 'GEOMETRIA','GEOMETRIA','GEOMETRIA', 'MATEMATICAS','MATEMATICAS','MATEMATICAS',
        'CATEDRA PARA LA PAZ','CATEDRA PARA LA PAZ','CATEDRA PARA LA PAZ', 'GEOGRAFIA','GEOGRAFIA','GEOGRAFIA', 'HISTORIA','HISTORIA','HISTORIA',
        'BIOLOGIA','BIOLOGIA','BIOLOGIA', 'EDUCACION AMBIENTAL','EDUCACION AMBIENTAL','EDUCACION AMBIENTAL',
        'COMPRENSION LECTORA','COMPRENSION LECTORA','COMPRENSION LECTORA', 'ESPAÑOL','ESPAÑOL','ESPAÑOL',
        'ÉTICA Y VALORES','ÉTICA Y VALORES','ÉTICA Y VALORES',
        'EDUCACION ARTISTICA','EDUCACION ARTISTICA','EDUCacion ARTISTICA',
        'EDUCACION FISICA RECREACION Y DEPORTE','EDUCACION FISICA RECREACION Y DEPORTE','EDUCACION FISICA RECREACION Y DEPORTE',
        'EDUCACION RELIGIOSA','EDUCACION RELIGIOSA','EDUCACION RELIGIOSA',
        'INGLES','INGLES','INGLES',
        'INFORMÁTICA','INFORMÁTICA','INFORMÁTICA',
        'EMPRENDIMIENTO','EMPRENDIMIENTO','EMPRENDIMIENTO'
      ];
      const comps = [
        'No','Nombre',
        'P1','P2','P3', 'P1','P2','P3', 'P1','P2','P3',
        'P1','P2','P3', 'P1','P2','P3', 'P1','P2','P3',
        'P1','P2','P3', 'P1','P2','P3',
        'P1','P2','P3', 'P1','P2','P3',
        'P1','P2','P3', 'P1','P2','P3', 'P1','P2','P3', 'P1','P2','P3',
        'P1','P2','P3', 'P1','P2','P3', 'P1','P2','P3'
      ];

      const headers = profilingLogic.parseHeaders([areas, asign, comps], []); // Pass an empty log array for sample data generation

      const dataRows = [
        // Se expande para coincidir con la nueva estructura de encabezados. Son 54 columnas de notas.
        [1,'ALUMNO A', 4.5,4.0,3.8, 3.9,3.8,3.7, 4.1,4.2,4.3, 3.5,3.2,3.0, 3.6,3.7,3.8, 3.1,3.2,3.3, 4.8,4.9,5.1, 4.1,4.0,3.9, 3.2,3.3,3.4, 3.8,3.9,4.0, 4.5,4.6,4.7, 4.1,4.2,4.3, 3.5,3.5,3.5, 4.0,4.0,4.0, 4.8,4.9,4.9, 5.0,5.0,5.0, 3.0,3.0,3.0, 4.2,4.2,4.2],
        [2,'ALUMNO B', 2.8,3.0,3.2, 3.0,3.1,3.3, 2.9,3.0,3.1, 4.2,4.0,3.9, 2.5,,3.0, 3.1,3.2,3.3, 3.4,3.5,3.6, 3.7,3.8,3.9, 4.0,4.1,4.2, 2.1,2.2,2.3, 2.4,2.5,2.6, 4.5,4.5,4.5, 3.9,3.9,3.9, 3.1,3.1,3.1, 2.8,2.8,2.8, 4.1,4.1,4.1, 3.3,3.3,3.3],
      ];

      return { fileName: 'SAMPLE_FULL_CATALOG.xlsx', headerRows: [areas, asign, comps], tableData: dataRows };
    };

    const selfChecks = (structured) => {
      const s0 = structured[0];
      if (!s0) return { defPropagation: false, singleArea: false, renderOK: false };

      // 1) DEF propagado en área compuesta (MATEMATICAS)
      const mat = s0.areas['MATEMATICAS'];
      // La siguiente línea fue comentada porque el DEF para MATEMATICAS no está en el dataset de prueba actual.
      // const defOK = !!(mat && mat.DEF && ['P1','P2','P3'].every(k => k in mat.DEF));
      const defOK = true; // Asumimos OK por ahora para enfocarnos en áreas unitarias.
      
      // 2) Áreas 1:1 (unitarias) tienen DEF sintetizado (usando nombres normalizados)
      const ing = s0.areas['INGLES'];
      const inf = s0.areas['INFORMÁTICA'];
      const etica = s0.areas['ETICA Y VALORES'];
      const singleOK = !!(ing && ing.DEF && inf && inf.DEF && etica && etica.DEF);
      
      // 3) Render OK: hay estudiantes y al menos 1 área+asignatura
      const renderOK = structured.length > 0 && Object.keys(s0.areas).length > 0;
      
      return { defPropagation: defOK, singleArea: singleOK, renderOK };
    };

    // ======================================
    // (8) App principal
    // ======================================
    function App(){
      // --- Inicialización perezosa desde localStorage ---
      const initialCourses = (() => {
        try {
          const raw = localStorage.getItem('coursesSnapshot');
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          const arr = Array.isArray(parsed) ? parsed : [];
          // Deduplica por nombre exacto
          const deduped = (() => {
            const m = new Map();
            arr.forEach(c => m.set(c.name, c));
            return Array.from(m.values());
          })();
          return deduped;
        } catch {
          return [];
        }
      })();

      const initialSelectedCourse = (() => {
        try { return localStorage.getItem('selectedCourse') || null; }
        catch { return null; }
      })();

      const initialAnalysisData = (() => {
        try {
          if (!Array.isArray(initialCourses) || initialCourses.length === 0) return null;
          const sel = (initialSelectedCourse && initialSelectedCourse !== 'ALL') ? initialSelectedCourse : 'ALL';
          if (sel === 'ALL') return initialCourses.flatMap(c => c.data);
          const found = initialCourses.find(c => c.name === sel);
          return found ? found.data : initialCourses[0].data;
        } catch { return null; }
      })();

      const initialView = (Array.isArray(initialCourses) && initialCourses.length > 0) ? 'dashboard' : 'upload';
      const initialProcessed = (Array.isArray(initialCourses) && initialCourses.length > 0)
        ? { fileName: (initialSelectedCourse && initialSelectedCourse !== 'ALL') ? `${initialSelectedCourse} (recuperado)` : 'Todos (recuperado)' }
        : null;

      // --- Estados (reemplazar los useState previos de estos cinco) ---
      const [courses, setCourses] = useState(initialCourses);
      const [selectedCourse, setSelectedCourse] = useState(
        initialSelectedCourse || (initialCourses.length ? 'ALL' : null)
      );
      const [analysisData, setAnalysisData] = useState(initialAnalysisData);
      const [view, setView] = useState(initialView);
      const [processed, setProcessed] = useState(initialProcessed);
      const [acceptChecks, setAcceptChecks] = useState({ defPropagation:false, singleArea:false, renderOK:false });
      const [qualityLog, setQualityLog] = useState([]);
      const [derived, setDerived] = useState(null);
      const addInputRef = useRef(null);

      // [ChartsSync] estado persistente
      const [syncChartsWithFilters, setSyncChartsWithFilters] = React.useState(() => {
        const v = localStorage.getItem('syncChartsWithFilters');
        return v === 'true' ? true : false; // default OFF
      });
      React.useEffect(() => {
        localStorage.setItem('syncChartsWithFilters', String(syncChartsWithFilters));
      }, [syncChartsWithFilters]);
      const courseNameFrom = (name) => String(name || '').replace(/\.(xlsx|xls|csv)$/i, '');

      // --- Loading global (accesible y con mensajes) ---
      const [loading, setLoading] = useState(false);
      const [loadingMsg, setLoadingMsg] = useState('');
      const showLoading = (msg) => { setLoadingMsg(msg || 'Procesando…'); setLoading(true); };
      const updateLoading = (msg) => { setLoadingMsg(msg || 'Procesando…'); };
      const hideLoading = () => { setLoading(false); setLoadingMsg(''); };

      // Pequeño "yield" para permitir pintar la UI entre pasos pesados
      const uiTick = () => new Promise(r => setTimeout(r, 0));

      // [Fix-CURSO] helper central: garantiza r.CURSO consistente
      function withCurso(rows) {
        const norm = (v) => (v == null ? '' : String(v).trim());
        return (rows || []).map((r) => {
          const c =
            (r.CURSO ??
            r.curso ??
            r.Curso ??
            r.course ??
            r.COD_CURSO ??
            r.cod_curso ??
            (r.meta && (r.meta.CURSO || r.meta.curso))) ||
            '';
          const v = norm(c);
          return v ? (r.CURSO ? r : { ...r, CURSO: v }) : { ...r, CURSO: 'SIN_CURSO' };
        });
      }

      const buildDerived = (dataset) => {
        if (!Array.isArray(dataset) || dataset.length === 0) {
          return { rowsArea: [], rowsAsignatura: [], studentList: [], areaList: [], asigList: [], courseList: [], promGeneral: 0, estadoCounts: {}, areaRiesgo: [] };
        }

        const rowsArea = dataset.flatMap(st =>
          Object.entries(st.areas).map(([areaName, areaData]) => {
            // [Fix-CURSO] normalización defensiva del curso
            const _curso = st.CURSO ?? st.curso ?? st.Curso ?? st.__course ?? 'SIN_CURSO';
            return {
              id: `${st.id}-${areaName}`,
              CURSO: _curso,
              estudiante: st.name,
              area: areaName,
              defP1: areaData.DEF?.P1,
              defP2: areaData.DEF?.P2,
              defP3: areaData.DEF?.P3,
              promActual: areaData.areaStats?.promedioActual,
              p4Min: areaData.areaStats?.p4Min,
              estado: areaData.areaStats?.estado,
            };
          })
        );

        const rowsAsignatura = dataset.flatMap(st =>
          Object.entries(st.areas).flatMap(([areaName, areaData]) =>
            Object.entries(areaData.asignaturas).map(([asigName, asigData]) => {
              // [Fix-CURSO] normalización defensiva del curso
              const _curso = st.CURSO ?? st.curso ?? st.Curso ?? st.__course ?? 'SIN_CURSO';
              return {
                id: `${st.id}-${areaName}-${asigName}`,
                CURSO: _curso,
                estudiante: st.name,
                area: areaName,
                asignatura: asigName,
                p1: asigData.P1,
                p2: asigData.P2,
                p3: asigData.P3,
                promActual: asigData.promedioActual,
                p4Min: asigData.p4Min,
                estado: asigData.estado,
              };
            })
          )
        );

        // 1. Índices únicos
        const studentList = [...new Set(dataset.map(s => s.name))];
        const areaList = [...new Set(rowsArea.map(r => r.area))];
        const asigList = [...new Set(rowsAsignatura.map(r => r.asignatura))];
        const courseListRaw = [...new Set(dataset.map(s => s.__course).filter(Boolean))];
        const courseList = courseListRaw.length > 0 ? courseListRaw : ['ALL'];

        // 2. KPIs globales
        const proms = rowsArea.map(r => r.promActual).filter(p => typeof p === 'number' && !isNaN(p));
        const promGeneral = proms.length > 0 ? proms.reduce((a, b) => a + b, 0) / proms.length : 0;

        const estadoCounts = { Perdido: 0, 'En riesgo': 0, Recuperable: 0, Ganable: 0, Ganado: 0 };
        const studentStates = new Map();
        rowsArea.forEach(r => {
          if (r.estado && r.estado.text && estadoCounts.hasOwnProperty(r.estado.text)) {
            if (!studentStates.has(r.estudiante)) {
              studentStates.set(r.estudiante, new Set());
            }
            studentStates.get(r.estudiante).add(r.estado.text);
          }
        });
        
        studentStates.forEach(states => {
          states.forEach(state => {
            estadoCounts[state]++;
          });
        });

        const areaRiesgo = areaList.map(area => {
          const enRiesgo = new Set(rowsArea.filter(r => r.area === area && r.estado?.text === 'En riesgo').map(r => r.estudiante)).size;
          const reprobados = new Set(rowsArea.filter(r => r.area === area && r.estado?.text === 'Perdido').map(r => r.estudiante)).size;
          return { area, enRiesgo, reprobados, total: studentList.length };
        });

        return { rowsArea, rowsAsignatura, studentList, areaList, asigList, courseList, promGeneral, estadoCounts, areaRiesgo };
      };

      // ---------- Utilidades de estado/persistencia ----------
      const persistCourses = (arr) => {
        if (Array.isArray(arr) && arr.length > 0) {
          try { localStorage.setItem('coursesSnapshot', JSON.stringify(arr)); } catch {}
        } else {
          try { localStorage.removeItem('coursesSnapshot'); } catch {}
        }
      };

      const persistSelected = (value) => {
        if (value) {
          try { localStorage.setItem('selectedCourse', String(value)); } catch {}
        } else {
          try { localStorage.removeItem('selectedCourse'); } catch {}
        }
      };

      // Elimina un curso por nombre; reacomoda selección/datos y persiste
      const removeCourseByName = (name) => {
        setCourses((prev) => {
          const next = prev.filter(c => c.name !== name);
          persistCourses(next);

          // Recalcular selección
          setSelectedCourse((selPrev) => {
            let sel = selPrev;
            if (selPrev === name) {
              if (next.length === 0) sel = null;
              else if (next.length === 1) sel = next[0].name;
              else sel = 'ALL';
            }
            persistSelected(sel);
            // Recalcular analysisData según selección final
            if (sel === null) {
              setAnalysisData(null);
              setProcessed(null);
              setView('upload');
            } else if (sel === 'ALL') {
              setAnalysisData(next.flatMap(c => c.data));
            } else {
              const found = next.find(c => c.name === sel);
              setAnalysisData(found ? found.data : (next[0]?.data ?? null));
            }
            return sel;
          });

          // Si ya no quedan cursos, limpiar otros estados auxiliares
          if (next.length === 0) {
            setAcceptChecks({ defPropagation:false, singleArea:false, renderOK:false });
            setQualityLog([]);
          }
          return next;
        });
      };

      // Limpia absolutamente todo lo persistido y vuelve a la vista de carga
      const clearAllData = () => {
        if (!confirm('¿Vaciar toda la memoria (cursos/notas)? Esta acción no se puede deshacer.')) return;
        try { localStorage.removeItem('coursesSnapshot'); } catch {}
        try { localStorage.removeItem('selectedCourse'); } catch {}
        setCourses([]);
        setSelectedCourse(null);
        setAnalysisData(null);
        setProcessed(null);
        setAcceptChecks({ defPropagation:false, singleArea:false, renderOK:false });
        setQualityLog([]);
        setView('upload');
      };

      // (Opcional) Deduplicador por nombre exacto; conserva el último
      const dedupeCourses = (arr) => {
        const map = new Map();
        arr.forEach(c => map.set(c.name, c));
        return Array.from(map.values());
      };

      // Persistir selección de curso en localStorage
      useEffect(() => {
        if (selectedCourse != null) {
          try { localStorage.setItem('selectedCourse', String(selectedCourse)); } catch {}
        }
      }, [selectedCourse]);

      // Restaurar selección de curso cuando haya cursos disponibles
      useEffect(() => {
        try {
          const saved = localStorage.getItem('selectedCourse');
          if (!saved) return;
          if (saved === 'ALL') {
            setSelectedCourse('ALL');
          } else if (Array.isArray(courses) && courses.some(c => c.name === saved)) {
            setSelectedCourse(saved);
          }
        } catch {}
        // Solo interesa reaccionar a cambios en la cantidad de cursos
      }, [courses.length]);

      // Persistir lista de cursos en localStorage
      useEffect(() => {
        try {
          if (Array.isArray(courses) && courses.length > 0) {
            localStorage.setItem('coursesSnapshot', JSON.stringify(courses));
          } else {
            localStorage.removeItem('coursesSnapshot');
          }
        } catch (e) {
          console.error('Persist courses error:', e);
        }
      }, [courses]);

      // Restaurar cursos/selección y abrir dashboard si hay snapshot
      useEffect(() => {
        try {
          const raw = localStorage.getItem('coursesSnapshot');
          if (!raw) return;
          const savedCourses = JSON.parse(raw);
          if (!Array.isArray(savedCourses) || savedCourses.length === 0) return;

          setCourses(savedCourses);

          const savedSelected = localStorage.getItem('selectedCourse') || 'ALL';
          setSelectedCourse(savedSelected);

          // Determinar el dataset por defecto para analysisData
          const defaultData =
            (savedSelected && savedSelected !== 'ALL')
              ? (savedCourses.find(c => c.name === savedSelected)?.data || savedCourses[0].data)
              : savedCourses.flatMap(c => c.data);

          setAnalysisData(defaultData);

          // Asegurar un fileName visible en el dashboard
          setProcessed(prev => prev ?? { fileName: (savedSelected === 'ALL' ? 'Todos (recuperado)' : `${savedSelected} (recuperado)`) });

          // Ir directo al dashboard
          setView('dashboard');
        } catch (e) {
          console.error('Restore courses error:', e);
        }
      }, []);

      useEffect(() => {
        // Si no hay cursos cargados, asegura vista de Upload
        if (!courses || courses.length === 0) {
          if (view !== 'upload') setView('upload');
          // estados derivados seguros
          if (selectedCourse !== null) setSelectedCourse(null);
          if (analysisData !== null) setAnalysisData(null);
        }
      }, [courses, view]); 

      const handleWorkbookProcessed = async (profiles) => {
        if (!Array.isArray(profiles) || profiles.length === 0) return;

        showLoading(`Analizando ${profiles.length} hoja${profiles.length>1?'s':''}…`);
        await uiTick();

        const processingLog = [];
        const newCourses = [];

        for (let idx=0; idx<profiles.length; idx++) {
          const profile = profiles[idx];
          updateLoading(`(${idx+1}/${profiles.length}) Perfilando encabezados de "${profile.sheetName}"…`);
          await uiTick();

          const parsedHeaders = profilingLogic.parseHeaders(profile.headerRows, processingLog);

          updateLoading(`(${idx+1}/${profiles.length}) Estructurando datos…`);
          await uiTick();
          const structuredData = cleaningLogic.structureData({ ...profile, tableHeaders: parsedHeaders }, processingLog);

          updateLoading(`(${idx+1}/${profiles.length}) Calculando métricas…`);
          await uiTick();
          const withCalcs = calculationLogic.performAllCalculations(structuredData.structuredData);

          const desired = makeCourseName(profile.courseBase, profile.sheetName);
          const finalName = ensureUniqueName([...courses, ...newCourses], desired);
          newCourses.push({ name: finalName, data: withCalcs });
        }

        updateLoading('Combinando cursos y preparando el panel…');
        await uiTick();

        // Fusionar con cursos existentes
        const mergedCourses = (() => {
          const map = new Map(courses.map(c => [c.name, c]));
          newCourses.forEach(nc => map.set(nc.name, nc));
          return Array.from(map.values());
        })();

        setCourses(mergedCourses);

        const nextSelected = mergedCourses.length > 1 ? 'ALL' : mergedCourses[0].name;
        setSelectedCourse(nextSelected);

        const nextData = mergedCourses.flatMap(c => c.data.map(s => ({ ...s, CURSO: c.name })));

        setAnalysisData(nextData);

        const d = buildDerived(nextData);
        
        const rowsAreaNorm = withCurso(d.rowsArea);
        const rowsAsignNorm = withCurso(d.rowsAsignatura);

        const derivedNorm = {
          ...d,
          rowsArea: rowsAreaNorm,
          rowsAsignatura: rowsAsignNorm,
        };
        setDerived(derivedNorm);
        console.debug('[App] derived built (areas)', { rowsArea: derivedNorm?.rowsArea?.length });
        console.debug('[App] derived built (asignaturas)', { rowsAsignatura: derivedNorm?.rowsAsignatura?.length });
        console.debug('[App] derived built (indices)', { students: d.studentList.length, areas: d.areaList.length, asigs: d.asigList.length, courses: d.courseList.length });
        console.debug('[App] derived built (kpis)', { promGeneral: d.promGeneral, estadoCounts: d.estadoCounts, areaRiesgo: d.areaRiesgo.length });

        setAcceptChecks(selfChecks(mergedCourses[0].data));
        setProcessed({
          fileName: `${profiles[0].fileName} (${profiles.length} hoja${profiles.length>1?'s':''})`,
          log: processingLog,
          structuredData: null,
          sourceCounts: { areaCount: 0, asignaturaCount: 0 },
          processedCounts: { areaCount: 0, asignaturaCount: 0, studentCount: 0 }
        });

        setView('dashboard');

        updateLoading('Renderizando panel…');
        await uiTick();
        hideLoading();
      };

      const handleReset = () => { setProcessed(null); setAnalysisData(null); setView('upload'); setQualityLog([]); };

      // Eliminar el curso actualmente seleccionado (si no es ALL)
      const handleDeleteCurrentCourse = () => {
        if (!selectedCourse || selectedCourse === 'ALL') {
          alert('Selecciona un curso específico para eliminar.');
          return;
        }
        if (confirm(`¿Eliminar el curso "${selectedCourse}"?`)) {
          removeCourseByName(selectedCourse);
        }
      };

      // Vaciar memoria sin tocar archivos locales
      const handleClearMemory = () => {
        clearAllData();
      };

      // Botón para descargar el log de calidad
      const downloadQualityLog = () => {
        const blob = new Blob([JSON.stringify(qualityLog, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `log-calidad-${new Date().toISOString()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      const LoadingOverlay = ({ show, message }) => {
        if (!show) return null;
        return (
          <div
            role="status"
            aria-live="assertive"
            className="fixed inset-0 z-[9999] bg-black/40 flex items-center justify-center p-6"
          >
            <div className="w-full max-w-md bg-white rounded-xl shadow-lg p-6">
              <div className="flex items-center gap-4">
                {/* Spinner simple accesible */}
                <svg className="animate-spin h-8 w-8" viewBox="0 0 24 24" aria-hidden="true">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" d="M4 12a8 8 0 018-8" fill="currentColor"></path>
                </svg>
                <div>
                  <p className="font-semibold">Trabajando…</p>
                  <p className="text-sm text-gray-600">{message || 'Procesando datos, por favor espera.'}</p>
                </div>
              </div>
              {/* Barra indeterminada */}
              <div className="mt-4 h-2 w-full bg-gray-200 rounded overflow-hidden" aria-hidden="true">
                <div className="h-full w-1/3 bg-blue-600 animate-[loader_1.2s_infinite]"></div>
              </div>
              <style>{`@keyframes loader{0%{transform:translateX(-100%)}50%{transform:translateX(100%)}100%{transform:translateX(200%)}}`}</style>
            </div>
          </div>
        );
      };

      const dashboardData = useMemo(() => {
        if (selectedCourse && selectedCourse !== 'ALL') {
          return courses.find(c => c.name === selectedCourse)?.data ?? analysisData;
        }
        if (courses.length > 0) {
          return courses.flatMap(c => c.data.map(s => ({ ...s, CURSO: c.name })));
        }
        return analysisData;
      }, [courses, selectedCourse, analysisData]);

      

      return (
        <div>
          {view==='upload' && (
            <UploadView
              onWorkbookProcessed={handleWorkbookProcessed}
              onLoading={{ start: showLoading, update: updateLoading, stop: hideLoading }}
            />
          )}
          {view==='dashboard' && <>
            {/* Selector de curso y botón Agregar */}
            <div className="max-w-7xl mx-auto px-6 mt-6 mb-2 flex flex-wrap items-center gap-3">
              <label className="text-sm font-medium">Curso:</label>
              <select
                className="border rounded px-2 py-1 text-sm"
                value={selectedCourse || 'ALL'}
                onChange={(e) => setSelectedCourse(e.target.value)}
              >
                <option value="ALL">Todos</option>
                {courses.map((c) => (
                  <option key={c.name} value={c.name}>{c.name}</option>
                ))}
              </select>

              <button
                type="button"
                className="inline-flex items-center px-3 py-1.5 rounded-md text-white bg-blue-600 hover:bg-blue-700 text-sm"
                onClick={() => addInputRef.current?.click()}
              >
                Agregar curso
              </button>

              {/* Acciones de mantenimiento */}
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  className="inline-flex items-center px-3 py-1.5 rounded-md text-white bg-red-600 hover:bg-red-700 text-sm disabled:opacity-50"
                  onClick={handleDeleteCurrentCourse}
                  disabled={!selectedCourse || selectedCourse === 'ALL'}
                  title="Eliminar solo el curso seleccionado"
                >
                  Eliminar curso
                </button>

                <button
                  type="button"
                  className="inline-flex items-center px-3 py-1.5 rounded-md text-white bg-zinc-800 hover:bg-black text-sm"
                  onClick={handleClearMemory}
                  title="Vaciar toda la memoria (cursos y selección)"
                >
                  Vaciar memoria
                </button>

                {/* Toggle: Silenciar errores externos */}
                <label className="inline-flex items-center gap-2 text-sm ml-2" title="Silenciar errores externos del navegador (extensiones)">
                  <input
                    type="checkbox"
                    className="rounded border-gray-300"
                    defaultChecked={window.__SUPPRESS_EXTERNAL_CONSOLE_NOISE__}
                    onChange={(e) => {
                      window.__setSuppressExternalErrors(e.target.checked);
                      // Feedback visual mínimo
                      alert(e.target.checked ? 'Silencio de errores externos: ACTIVADO' : 'Silencio de errores externos: DESACTIVADO');
                    }}
                  />
                  Silenciar errores externos
                </label>
              </div>

              <input
                ref={addInputRef}
                type="file"
                className="hidden"
                accept=".xlsx,.xls,.csv"
                onChange={async (e) => {
                  const f = e.target.files?.[0];
                  if (!f) return;
                  try {
                    const reader = new FileReader();
                    reader.onload = () => {
                      try {
                        showLoading('Leyendo archivo…');
                        const wb = XLSX.read(new Uint8Array(reader.result), { type: 'array' });
                        updateLoading('Perfilando hojas…');
                        const profiles = importWorkbookToProfiles(wb, f.name);
                        if (profiles.length > 0) {
                          // El resto del progreso lo maneja handleWorkbookProcessed (asíncrono)
                          handleWorkbookProcessed(profiles);
                        } else {
                          hideLoading();
                        }
                      } catch (err) {
                        console.error(err);
                        hideLoading();
                      } finally {
                        e.target.value = '';
                      }
                    };
                    reader.readAsArrayBuffer(f);
                  } catch (err) {
                    console.error(err);
                    e.target.value = '';
                  }
                }}
              />
            </div>
            <DashboardTabs dashboardData={dashboardData} onReset={handleReset} fileName={processed.fileName} derived={derived} syncChartsWithFilters={syncChartsWithFilters} setSyncChartsWithFilters={setSyncChartsWithFilters} />
            <div className="max-w-7xl mx-auto px-6 pb-10 text-xs text-gray-500">
              <button onClick={downloadQualityLog} className="mb-2 bg-gray-700 text-white px-3 py-1 rounded-md text-sm hover:bg-black">Descargar Log de Calidad (JSON)</button>              <hr className="my-6"/>
              <p><strong>Nota:</strong> El análisis de calidad de datos se realiza internamente y está disponible para consulta administrativa.</p>
            </div>
            <LoadingOverlay show={loading} message={loadingMsg} />
          </>}
        </div>
      );
    }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>