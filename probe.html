<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prueba de Carga de Excel</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, "Noto Sans", 'Apple Color Emoji', 'Segoe UI Emoji'; }
    .highlight-unitary { background-color: #f0f9ff; border-left: 3px solid #3b82f6; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, Fragment } = React;

    // ==============================================
    // Utilidades de Normalización
    // ==============================================
    const textNormalize = (v) => (typeof v === 'string' ? v.trim() : v);
    const toUpperSafe = (v) => (v == null ? '' : String(v).trim().toUpperCase());
    const removeDiacritics = (str) => (str || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '');

    const normalizeName = (s) => {
      let v = toUpperSafe(s);
      v = removeDiacritics(v);
      return v.replace(/\s+/g, ' ').trim();
    }

    const normalizeAsignatura = (s) => {
      const v = normalizeName(s);
      if (/^(DEF(\.|INIT)?|DEFINITIVA|DEF AREA|AREA DEF)\b/.test(v)) return 'DEF';
      return v;
    };

    const normalizeArea = (s) => normalizeName(s);
    const normalizeComponente = (s) => {
      let v = toUpperSafe(s);
      v = removeDiacritics(v);
      v = v.replace(/\s+/g, '');
      if (/^(P1|1P|PRIMERO|PER1|PERIODO1)$/i.test(v)) return 'P1';
      if (/^(P2|2P|SEGUNDO|PER2|PERIODO2)$/i.test(v)) return 'P2';
      if (/^(P3|3P|TERCERO|PER3|PERIODO3)$/i.test(v)) return 'P3';
      if (/^(A|ACUMULADO|ACUM)$/.test(v)) return 'A';
      const defPx = v.match(/^DEF(P[123])$/);
      if (defPx) return defPx[1];
      return v || '';
    };

    // ========================================
    // Lógica de Parseo de Encabezados
    // ========================================
    const parseHeaders = (headerRows, log) => {
      const [rawAreas, rawAsignaturas, rawComponentes] = headerRows;
      log.push({ level: 'info', message: `Filas de encabezado detectadas: ${headerRows.length}` });

      // 1. Forward fill en Áreas
      for (let i = 1; i < rawAreas.length; i++) {
        if (!textNormalize(rawAreas[i])) rawAreas[i] = rawAreas[i - 1];
      }
      log.push({ level: 'info', message: `Áreas después de forward-fill: ${JSON.stringify(rawAreas)}` });

      // 2. Forward fill contextual en Asignaturas
      for (let i = 1; i < rawAsignaturas.length; i++) {
        if (!textNormalize(rawAsignaturas[i]) && textNormalize(rawAreas[i]) === textNormalize(rawAreas[i - 1])) {
          rawAsignaturas[i] = rawAsignaturas[i - 1];
        }
      }
      log.push({ level: 'info', message: `Asignaturas después de forward-fill contextual: ${JSON.stringify(rawAsignaturas)}` });

      // 3. Relleno de Asignatura con Área para áreas 1:1
      for (let i = 0; i < rawAsignaturas.length; i++) {
        if (!textNormalize(rawAsignaturas[i])) {
          rawAsignaturas[i] = rawAreas[i];
        }
      }
      log.push({ level: 'info', message: `Asignaturas después de relleno 1:1: ${JSON.stringify(rawAsignaturas)}` });

      // 4. Estructurar y normalizar, OMITIENDO las primeras dos columnas (No, Estudiante)
      const structuredHeaders = rawComponentes.map((comp, i) => ({
        index: i,
        area: normalizeArea(rawAreas[i]),
        asignatura: normalizeAsignatura(rawAsignaturas[i]),
        componente: normalizeComponente(comp),
        raw: { area: rawAreas[i], asignatura: rawAsignaturas[i], componente: comp }
      })).slice(2); // <-- CORRECCIÓN CLAVE: Omitir las dos primeras columnas.
      
      log.push({ level: 'info', message: `Cabeceras estructuradas y normalizadas generadas.` });
      
      return structuredHeaders.filter(h => h.area && h.asignatura);
    };

    // ========================================
    // Lógica de Estructuración de Datos de Estudiantes (Fase 2)
    // ========================================
    const structureStudentData = (dataRows, headers, log) => {
      const students = [];
      const studentNames = new Set();

      dataRows.forEach((row, rowIndex) => {
        const studentId = textNormalize(row[0]);
        const studentName = textNormalize(row[1]);

        if (!studentName) {
          log.push({ level: 'warn', message: `Fila ${rowIndex + 4}: Estudiante sin nombre. Fila omitida.` });
          return;
        }
        if (studentNames.has(studentName)) {
          log.push({ level: 'warn', message: `Estudiante duplicado: \"${studentName}\". Se procesará, pero revise duplicidad.` });
        }
        studentNames.add(studentName);

        const student = { id: studentId, name: studentName, areas: {} };

        headers.forEach(h => {
          const { area, asignatura, componente, index } = h;
          if (!student.areas[area]) {
            student.areas[area] = { asignaturas: {}, DEF: {} };
          }

          let note = (() => {
            const v = row[index];
            if (v === null || v === undefined) return null;
            let s = String(v).trim();
            if (!s || s === '—' || s.toUpperCase() === 'NA') return null;
            const num = parseFloat(s.replace(',', '.'));
            return Number.isFinite(num) ? num : null;
          })();

          if (row[index] !== null && String(row[index]).trim() !== '' && note === null) {
            log.push({ level: 'warn', message: `Dato no numérico para \"${studentName}\" en ${area}>${asignatura}>${componente}: '${row[index]}' fue tratado como nulo.` });
          }
          if (note !== null && (note < 0 || note > 5)) {
            log.push({ level: 'error', message: `Nota fuera de rango para \"${studentName}\" en ${area}>${asignatura}>${componente}: '${note}' fue descartada.` });
            note = null;
          }

          if (asignatura === 'DEF') {
            if (['P1', 'P2', 'P3'].includes(componente)) {
              student.areas[area].DEF[componente] = note;
            }
          } else {
            if (!student.areas[area].asignaturas[asignatura]) {
              student.areas[area].asignaturas[asignatura] = {};
            }
            if (['P1', 'P2', 'P3'].includes(componente)) {
              student.areas[area].asignaturas[asignatura][componente] = note;
            }
          }
        });

        // Síntesis de DEF para áreas unitarias
        Object.entries(student.areas).forEach(([areaName, areaData]) => {
          const hasExplicitDEF = Object.values(areaData.DEF).some(v => v !== null);
          if (!hasExplicitDEF) {
            const mainAsignatura = areaData.asignaturas[areaName];
            if (mainAsignatura) {
              areaData.DEF = { ...mainAsignatura };
              log.push({ level: 'info', message: `Área unitaria \"${areaName}\": DEF sintetizado desde asignatura.` });
            }
          }
        });

        students.push(student);
      });
      return students;
    };

    // ========================================
    // Componente Principal: ExcelLoadProbe
    // ========================================
    function ExcelLoadProbe() {
      const [file, setFile] = useState(null);
      const [processing, setProcessing] = useState(false);
      const [analysis, setAnalysis] = useState(null);
      const [studentData, setStudentData] = useState([]);
      const [log, setLog] = useState([]);
      const inputRef = useRef(null);

      const processExcelFile = (file) => {
        setProcessing(true);
        setAnalysis(null);
        setStudentData([]);
        const currentLog = [];
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
            currentLog.push({ level: 'info', message: `Archivo "${file.name}" leído.` });
            
            const sheetName = wb.SheetNames[0];
            if (!sheetName) {
              currentLog.push({ level: 'error', message: "El archivo no contiene hojas." });
              setLog(currentLog);
              setProcessing(false);
              return;
            }
            
            const ws = wb.Sheets[sheetName];
            
            const range = XLSX.utils.decode_range(ws['!ref']);
            const max_col = range.e.c;
            const data = XLSX.utils.sheet_to_json(ws, { header: 1, blankrows: false, range: `A1:${XLSX.utils.encode_col(max_col)}42` });
            currentLog.push({ level: 'info', message: `Hoja "${sheetName}" seleccionada. Rango detectado: A1-${XLSX.utils.encode_col(max_col)}42.` });

            if (data.length < 3) {
              currentLog.push({ level: 'error', message: "Se requieren al menos 3 filas de encabezado." });
              setLog(currentLog);
              setProcessing(false);
              return;
            }

            const headerRows = data.slice(0, 3).map(row => {
                const fullRow = [...row];
                while (fullRow.length <= max_col) {
                    fullRow.push(undefined);
                }
                return fullRow;
            });
            const dataRows = data.slice(3);

            // Fase 1: Análisis de Catálogo
            const headers = parseHeaders(headerRows, currentLog);
            const areaMap = new Map();
            headers.forEach(h => {
              if (h.asignatura !== 'DEF') {
                if (!areaMap.has(h.area)) {
                  areaMap.set(h.area, new Set());
                }
                areaMap.get(h.area).add(h.asignatura);
              }
            });
            const areas = Array.from(areaMap.keys()).sort();
            const asignaturas = new Set();
            areaMap.forEach(asigs => asigs.forEach(a => asignaturas.add(a)));

            setAnalysis({
              fileName: file.name,
              sheetName,
              totalColumns: max_col + 1,
              totalRows: data.length,
              areas,
              asignaturas: Array.from(asignaturas).sort(),
              areaMap,
              headers
            });

            // Fase 2: Extracción de Notas
            const structuredData = structureStudentData(dataRows, headers, currentLog);
            setStudentData(structuredData);

          } catch (err) {
            currentLog.push({ level: 'error', message: `Error catastrófico al procesar el archivo: ${err.message}` });
          }
          setLog(currentLog);
          setProcessing(false);
        };
        reader.onerror = () => {
          currentLog.push({ level: 'error', message: "No se pudo leer el archivo." });
          setLog(currentLog);
          setProcessing(false);
        };
        reader.readAsArrayBuffer(file);
      };

      const handleFileSelect = (files) => {
        if (files && files[0]) {
          setFile(files[0]);
          processExcelFile(files[0]);
        }
      };
      
      const downloadLog = () => {
        const blob = new Blob([JSON.stringify(log, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `log-probe-${new Date().toISOString()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      };

      return (
        <div className="max-w-7xl mx-auto p-6 space-y-6">
          <div className="text-center">
            <h1 className="text-3xl font-bold">Módulo de Prueba de Carga de Excel</h1>
            <p className="text-gray-600">Fase 2: Análisis de Catálogo y Verificación de Notas</p>
          </div>

          {/* Uploader */}
          <div className="bg-white p-6 rounded-xl border border-gray-200">
            <div 
              className="flex justify-center items-center w-full h-32 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50"
              onClick={() => inputRef.current.click()}
              onDrop={(e) => { e.preventDefault(); handleFileSelect(e.dataTransfer.files); }}
              onDragOver={(e) => e.preventDefault()}
            >
              <p className="text-gray-500">{file ? `Archivo cargado: ${file.name}` : "Arrastra un archivo de Excel o haz clic para seleccionar"}</p>
              <input type="file" ref={inputRef} className="hidden" onChange={(e) => handleFileSelect(e.target.files)} accept=".xlsx,.xls,.csv" />
            </div>
            {file && <button onClick={() => processExcelFile(file)} className="mt-4 w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 disabled:bg-gray-400" disabled={processing}>{processing ? "Procesando..." : "Reintentar Análisis"}</button>}
          </div>

          {/* Results */}
          {analysis && (
            <div className="bg-white p-6 rounded-xl border border-gray-200 space-y-4">
              <h2 className="text-xl font-bold">Fase 1: Resultados del Catálogo</h2>
              
              <div><strong>Archivo:</strong> {analysis.fileName}</div>
              <div><strong>Hoja:</strong> {analysis.sheetName} ({analysis.totalRows} filas, {analysis.totalColumns} columnas)</div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Areas */}
                <div>
                  <h3 className="font-semibold text-lg">Áreas Detectadas ({analysis.areas.length})</h3>
                  <ul className="list-disc list-inside bg-gray-50 p-3 rounded-md max-h-60 overflow-y-auto">
                    {analysis.areas.map(area => <li key={area}>{area}</li>)}
                  </ul>
                </div>
                {/* Asignaturas */}
                <div>
                  <h3 className="font-semibold text-lg">Asignaturas Detectadas ({analysis.asignaturas.length})</h3>
                  <ul className="list-disc list-inside bg-gray-50 p-3 rounded-md max-h-60 overflow-y-auto">
                    {analysis.asignaturas.map(asig => <li key={asig}>{asig}</li>)}
                  </ul>
                </div>
              </div>

              {/* Matriz */}
              <div>
                <h3 className="font-semibold text-lg">Matriz Área &lt;=&gt; Asignaturas</h3>
                <div className="space-y-2">
                  {analysis.areas.map(area => {
                    const asignaturasDelArea = Array.from(analysis.areaMap.get(area) || []);
                    const esUnitaria = asignaturasDelArea.length === 1 && asignaturasDelArea[0] === area;
                    return (
                      <div key={area} className={`p-3 rounded-md border ${esUnitaria ? 'highlight-unitary' : 'bg-white'}`}>
                        <div className="font-bold">{area} {esUnitaria && <span className="text-xs font-medium bg-blue-100 text-blue-800 px-2 py-1 rounded-full ml-2">ÁREA UNITARIA</span>}</div>
                        <ul className="list-disc list-inside ml-4 text-sm text-gray-700">
                          {asignaturasDelArea.map(asig => <li key={asig}>{asig}</li>)}
                        </ul>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          )}

          {studentData.length > 0 && (
            <div className="bg-white p-6 rounded-xl border border-gray-200 space-y-4">
              <h2 className="text-xl font-bold">Fase 2: Verificación de Notas</h2>
              
              {/* Tabla de Análisis por Asignatura */}
              <h3 className="font-semibold text-lg">Análisis por Asignatura</h3>
              <div className="overflow-x-auto border rounded-lg">
                <table className="min-w-full divide-y divide-gray-200 text-xs">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-2 py-2 text-left font-medium text-gray-500">Estudiante</th>
                      <th className="px-2 py-2 text-left font-medium text-gray-500">Área</th>
                      <th className="px-2 py-2 text-left font-medium text-gray-500">Asignatura</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500">P1</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500">P2</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500">P3</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {studentData.slice(0, 5).flatMap(student => 
                      Object.entries(student.areas).flatMap(([areaName, areaData]) => 
                        Object.entries(areaData.asignaturas).map(([asigName, asigData]) => (
                          <tr key={`${student.id}-${areaName}-${asigName}`}>
                            <td className="px-2 py-2 whitespace-nowrap">{student.name}</td>
                            <td className="px-2 py-2">{areaName}</td>
                            <td className="px-2 py-2">{asigName}</td>
                            <td className="px-2 py-2 text-center">{asigData.P1 ?? '-'}</td>
                            <td className="px-2 py-2 text-center">{asigData.P2 ?? '-'}</td>
                            <td className="px-2 py-2 text-center">{asigData.P3 ?? '-'}</td>
                          </tr>
                        ))
                      )
                    )}
                  </tbody>
                </table>
              </div>

              {/* Tabla de Análisis por Área */}
              <h3 className="font-semibold text-lg mt-6">Análisis por Área (Notas Definitivas)</h3>
              <div className="overflow-x-auto border rounded-lg">
                <table className="min-w-full divide-y divide-gray-200 text-xs">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-2 py-2 text-left font-medium text-gray-500">Estudiante</th>
                      <th className="px-2 py-2 text-left font-medium text-gray-500">Área</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500 bg-blue-50">DEF P1</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500 bg-blue-50">DEF P2</th>
                      <th className="px-2 py-2 text-center font-medium text-gray-500 bg-blue-50">DEF P3</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {studentData.slice(0, 5).flatMap(student => 
                      Object.entries(student.areas).map(([areaName, areaData]) => (
                        <tr key={`${student.id}-${areaName}`}>
                          <td className="px-2 py-2 whitespace-nowrap">{student.name}</td>
                          <td className="px-2 py-2">{areaName}</td>
                          <td className="px-2 py-2 text-center bg-blue-50 font-medium">{areaData.DEF?.P1 ?? '-'}</td>
                          <td className="px-2 py-2 text-center bg-blue-50 font-medium">{areaData.DEF?.P2 ?? '-'}</td>
                          <td className="px-2 py-2 text-center bg-blue-50 font-medium">{areaData.DEF?.P3 ?? '-'}</td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {log.length > 0 && (
            <div className="bg-white p-6 rounded-xl border border-gray-200 space-y-4">
              <h3 className="font-semibold text-lg">Log de Procesamiento</h3>
              <button onClick={downloadLog} className="mb-2 bg-gray-700 text-white px-3 py-1 rounded-md text-sm hover:bg-black">Descargar Log (JSON)</button>
              <div className="bg-gray-900 text-white font-mono text-xs p-4 rounded-md max-h-80 overflow-y-auto">
                {log.map((l, i) => <div key={i} className={l.level === 'error' ? 'text-red-400' : 'text-gray-300'}>{`[${l.level.toUpperCase()}] ${l.message}`}</div>)}
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<ExcelLoadProbe />, document.getElementById('root'));
  </script>
</body>
</html>